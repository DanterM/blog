<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F04%2F21%2FGit%2F</url>
    <content type="text"><![CDATA[选自廖雪峰的官方网站 一、创建版本库1、创建空目录1234$ mkdir learngit$ cd learngit$ pwd/Users/Jarvis/learngit pwd命令用于显示当前目录，在Mac上，仓库位于/Users/Jarvis/learngit 2、git init12$ git initInitialized empty Git repository in /Users/Jarvis/learngit/.git/ 之后当前目录下多了一个 .git 的目录，这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。 3、添加文件到版本库自己新建一个文件放到 learngit 目录下。一定要放到 learngit 目录下（子目录也行），因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令 git add 告诉 Git ，把文件添加到仓库： 1$ git add readme.txt 执行上面的命令，没有任何显示，这就对了， Unix 的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令 git commit 告诉 Git ，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下 git commit 命令， -m 后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入 -m “xxx” 行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行 Google ，我不告诉你这个参数。 git commit 命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么 Git 添加文件需要 add ， commit 一共两步呢？因为 commit 可以一次提交很多文件，所以你可以多次 add 不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 二、时光机穿梭我们已经添加了文件，现在我们已经对文件进行了修改。 修改后，我们运行 git status 命令看看结果： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status 命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们， readme.txt 被修改过了，但还没有准备提交的修改。 虽然 Git 告诉我们 readme.txt 被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你周末休息回来，周一上班时，已经记不清上次怎么修改的 readme.txt ，所以，需要用 git diff 这个命令看看： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 1$ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： 1234567$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： 123$ git commit -m &quot;add distributed&quot;[master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： 123$ git status# On branch masternothing to commit (working directory clean) Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 1、版本回退在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在 Git 中，我们用 git log 命令查看 git log命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 –pretty=oneline 参数： 1$ git log --pretty=oneline 需要友情提示的是，你看到的一大串类似3628164…882e1e0的是 commit id （版本号），和 SVN 不一样， Git 的 commit id 不是1，2，3……递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，而且你看到的 commit id 和我的肯定不一样，以你自己的为准。为什么 commit id 需要用这么一大串数字表示呢？因为 Git 是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，应该怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本 “append GPL” 回退到上一个版本 “add distributed” ，就可以使用 git reset 命令： 12$ git reset --hard HEAD^HEAD is now at ea34578 add distributed –hard 参数有啥意义？这个后面再讲，现在你先放心使用。 看看 readme.txt 的内容是不是版本 add distributed ： 123$ cat readme.txtGit is a distributed version control system.Git is free software.]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3入门]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[CSS3 被划分为模块。 其中最重要的 CSS3 模块包括： 选择器 框模型 背景和边框 文本效果 2D/3D 转换 动画 多列布局 用户界面 CSS3 边框 通过 CSS3，您能够创建圆角边框，向矩形添加阴影，使用图片来绘制边框 - 并且不需使用设计软件，比如 PhotoShop。 在本章中，您将学到以下边框属性： border-radius box-shadow border-image Internet Explorer 9+ 支持 border-radius 和 box-shadow 属性。 Firefox、Chrome 以及 Safari 支持所有新的边框属性。 注释：对于 border-image，Safari 5 以及更老的版本需要前缀 -webkit-。 Opera 支持 border-radius 和 box-shadow 属性，但是对于 border-image 需要前缀 -o-。 CSS3 圆角边框 在 CSS2 中添加圆角矩形需要技巧。我们必须为每个圆角使用不同的图片。 在 CSS3 中，创建圆角是非常容易的。 在 CSS3 中，border-radius 属性用于创建圆角： 实例向 div 元素添加圆角： 123456div&#123;border:2px solid;border-radius:25px;-moz-border-radius:25px; /* Old Firefox */&#125; CSS3 边框阴影在 CSS3 中，box-shadow 用于向方框添加阴影：实例向 div 元素添加方框阴影： 1234div&#123;box-shadow: 10px 10px 5px #888888;&#125; CSS3 边框图片通过 CSS3 的 border-image 属性，您可以使用图片来创建边框. 实例使用图片创建围绕 div 元素的边框： 1234567div&#123;border-image:url(border.png) 30 30 round;-moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */-webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */-o-border-image:url(border.png) 30 30 round; /* Opera */&#125; CSS3 背景 CSS3 包含多个新的背景属性，它们提供了对背景更强大的控制。 在本章，您将学到以下背景属性： background-size background-origin Internet Explorer 9+、Firefox、Chrome、Safari 以及 Opera 支持新的背景属性。 CSS3 background-size 属性background-size 属性规定背景图片的尺寸。 在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。 您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 例子 1调整背景图片的大小： 1234567div&#123;background:url(bg_flower.gif);-moz-background-size:63px 100px; /* 老版本的 Firefox */background-size:63px 100px;background-repeat:no-repeat;&#125; 例子 2对背景图片进行拉伸，使其完成填充内容区域： 1234567div&#123;background:url(bg_flower.gif);-moz-background-size:40% 100%; /* 老版本的 Firefox */background-size:40% 100%;background-repeat:no-repeat;&#125; CSS3 background-origin 属性background-origin 属性规定背景图片的定位区域。 背景图片可以放置于 content-box、padding-box 或 border-box 区域。 实例在 content-box 中定位背景图片： 12345678div&#123;background:url(bg_flower.gif);background-repeat:no-repeat;background-size:100% 100%;-webkit-background-origin:content-box; /* Safari */background-origin:content-box;&#125; CSS3 多重背景图片CSS3 允许您为元素使用多个背景图像。 实例为 body 元素设置两幅背景图片： 1234body&#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif);&#125; CSS3 文本效果 CSS3 包含多个新的文本特性。 在本章中，您将学到如下文本属性： text-shadow word-wrap Internet Explorer 10、Firefox、Chrome、Safari 以及 Opera 支持 text-shadow 属性。 所有主流浏览器都支持 word-wrap 属性。 注释：Internet Explorer 9 以及更早的版本，不支持 text-shadow 属性。 CSS3 文本阴影在 CSS3 中，text-shadow 可向文本应用阴影。 您能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色： 实例向标题添加阴影： 1234h1&#123;text-shadow: 5px 5px 5px #FF0000;&#125; CSS3 自动换行单词太长的话就可能无法超出某个区域 在 CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行 - 即使这意味着会对单词进行拆分 下面是 CSS 代码： 实例允许对长单词进行拆分，并换行到下一行： 1p &#123;word-wrap:break-word;&#125; CSS3 字体 CSS3 @font-face 规则在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。 通过 CSS3，web 设计师可以使用他们喜欢的任意字体。 当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。 您“自己的”的字体是在 CSS3 @font-face 规则中定义的。 Firefox、Chrome、Safari 以及 Opera 支持 .ttf (True Type Fonts) 和 .otf (OpenType Fonts) 类型的字体。Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。注释：Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。 使用您需要的字体在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。 如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)： 实例 12345678910111213&lt;style&gt; @font-face&#123;font-family: myFirstFont;src: url(&apos;Sansation_Light.ttf&apos;), url(&apos;Sansation_Light.eot&apos;); /* IE9+ */&#125;div&#123;font-family:myFirstFont;&#125;&lt;/style&gt; 使用粗体字体您必须为粗体文本添加另一个包含描述符的 @font-face： 实例 1234567@font-face&#123;font-family: myFirstFont;src: url(&apos;Sansation_Bold.ttf&apos;), url(&apos;Sansation_Bold.eot&apos;); /* IE9+ */font-weight:bold;&#125; 文件 “Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。通过这种方式，我们可以为相同的字体设置许多 @font-face 规则。 下面的表格列出了能够在 @font-face 规则中定义的所有字体描述符： CSS3 2D 转换 CSS3 转换通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 转换是使元素改变形状、尺寸和位置的一种效果。 您可以使用 2D 或 3D 转换来转换您的元素。 Internet Explorer 10、Firefox 以及 Opera 支持 transform 属性。Chrome 和 Safari 需要前缀 -webkit-。注释：Internet Explorer 9 需要前缀 -ms-。 2D 转换在本章中，您将学到如下 2D 转换方法： translate() rotate() scale() skew() matrix() 实例 12345678div&#123;transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */-o-transform: rotate(30deg); /* Opera */-moz-transform: rotate(30deg); /* Firefox */&#125; translate() 方法通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 实例 12345678div&#123;transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */-o-transform: translate(50px,100px); /* Opera */-moz-transform: translate(50px,100px); /* Firefox */&#125; 值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。 rotate() 方法通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 实例 12345678div&#123;transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */-o-transform: rotate(30deg); /* Opera */-moz-transform: rotate(30deg); /* Firefox */&#125; 值 rotate(30deg) 把元素顺时针旋转 30 度。 scale() 方法通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： 实例 12345678div&#123;transform: scale(2,4);-ms-transform: scale(2,4); /* IE 9 */-webkit-transform: scale(2,4); /* Safari 和 Chrome */-o-transform: scale(2,4); /* Opera */-moz-transform: scale(2,4); /* Firefox */&#125; 值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 skew() 方法通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数： 实例 12345678div&#123;transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */-o-transform: skew(30deg,20deg); /* Opera */-moz-transform: skew(30deg,20deg); /* Firefox */&#125; 值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 matrix() 方法matrix() 方法把所有 2D 转换方法组合在一起。 matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 实例如何使用 matrix 方法将 div 元素旋转 30 度： 12345678div&#123;transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */-o-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Opera */&#125; CSS3 3D 转换 3D 转换CSS3 允许您使用 3D 转换来对元素进行格式化。 在本章中，您将学到其中的一些 3D 转换方法： rotateX() rotateY() Internet Explorer 10 和 Firefox 支持 3D 转换。Chrome 和 Safari 需要前缀 -webkit-。Opera 仍然不支持 3D 转换（它只支持 2D 转换）。 rotateX() 方法通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转。 实例 123456div&#123;transform: rotateX(120deg);-webkit-transform: rotateX(120deg); /* Safari 和 Chrome */-moz-transform: rotateX(120deg); /* Firefox */&#125; rotateY() 旋转通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转。 实例 123456div&#123;transform: rotateY(130deg);-webkit-transform: rotateY(130deg); /* Safari 和 Chrome */-moz-transform: rotateY(130deg); /* Firefox */&#125; CSS3 过渡 CSS3 过渡通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 Internet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。Safari 需要前缀 -webkit-。注释：Internet Explorer 9 以及更早的版本，不支持 transition 属性。注释：Chrome 25 以及更早的版本，需要前缀 -webkit-。 它如何工作？CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。 要实现这一点，必须规定两项内容： 规定您希望把效果添加到哪个 CSS 属性上 规定效果的时长 实例应用于宽度属性的过渡效果，时长为 2 秒： 1234567div&#123;transition: width 2s;-moz-transition: width 2s; /* Firefox 4 */-webkit-transition: width 2s; /* Safari 和 Chrome */-o-transition: width 2s; /* Opera */&#125; 注释：如果时长未规定，则不会有过渡效果，因为默认值是 0。 效果开始于指定的 CSS 属性改变值时。CSS 属性改变的典型时间是鼠标指针位于元素上时： 实例规定当鼠标指针悬浮于 元素上时： 1234div:hover&#123;width:300px;&#125; 注释：当指针移出元素时，它会逐渐变回原来的样式。 多项改变如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开： 实例向宽度、高度和转换添加过渡效果： 1234567div&#123;transition: width 2s, height 2s, transform 2s;-moz-transition: width 2s, height 2s, -moz-transform 2s;-webkit-transition: width 2s, height 2s, -webkit-transform 2s;-o-transition: width 2s, height 2s,-o-transform 2s;&#125; 过渡属性下面的表格列出了所有的转换属性： 下面的两个例子设置所有过渡属性： 实例在一个例子中使用所有过渡属性： 12345678910111213141516171819202122div&#123;transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s;/* Firefox 4 */-moz-transition-property:width;-moz-transition-duration:1s;-moz-transition-timing-function:linear;-moz-transition-delay:2s;/* Safari 和 Chrome */-webkit-transition-property:width;-webkit-transition-duration:1s;-webkit-transition-timing-function:linear;-webkit-transition-delay:2s;/* Opera */-o-transition-property:width;-o-transition-duration:1s;-o-transition-timing-function:linear;-o-transition-delay:2s;&#125; 实例与上面的例子相同的过渡效果，但是使用了简写的 transition 属性： 12345678910div&#123;transition: width 1s linear 2s;/* Firefox 4 */-moz-transition:width 1s linear 2s;/* Safari and Chrome */-webkit-transition:width 1s linear 2s;/* Opera */-o-transition:width 1s linear 2s;&#125; CSS3 动画 通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 CSS3 @keyframes 规则如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。 @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。Chrome 和 Safari 需要前缀 -webkit-。注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 实例 1234567891011121314151617181920212223@keyframes myfirst&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125; CSS3 动画当您在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 实例把 “myfirst” 动画捆绑到 div 元素，时长：5 秒： 1234567div&#123;animation: myfirst 5s;-moz-animation: myfirst 5s; /* Firefox */-webkit-animation: myfirst 5s; /* Safari 和 Chrome */-o-animation: myfirst 5s; /* Opera */&#125; 注释：您必须定义动画的名称和时长。如果忽略时长，则动画不会允许，因为默认值是 0。 什么是 CSS3 中的动画？动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 实例当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变： 12345678910111213141516171819202122232425262728293031@keyframes myfirst&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125; 实例改变背景色和位置： 1234567891011121314151617181920212223242526272829303132333435@keyframes myfirst&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125; CSS3 动画属性下面的表格列出了 @keyframes 规则和所有动画属性： 下面的两个例子设置了所有动画属性： 实例运行名为 myfirst 的动画，其中设置了所有动画属性： 12345678910111213141516171819202122232425262728293031323334div&#123;animation-name: myfirst;animation-duration: 5s;animation-timing-function: linear;animation-delay: 2s;animation-iteration-count: infinite;animation-direction: alternate;animation-play-state: running;/* Firefox: */-moz-animation-name: myfirst;-moz-animation-duration: 5s;-moz-animation-timing-function: linear;-moz-animation-delay: 2s;-moz-animation-iteration-count: infinite;-moz-animation-direction: alternate;-moz-animation-play-state: running;/* Safari 和 Chrome: */-webkit-animation-name: myfirst;-webkit-animation-duration: 5s;-webkit-animation-timing-function: linear;-webkit-animation-delay: 2s;-webkit-animation-iteration-count: infinite;-webkit-animation-direction: alternate;-webkit-animation-play-state: running;/* Opera: */-o-animation-name: myfirst;-o-animation-duration: 5s;-o-animation-timing-function: linear;-o-animation-delay: 2s;-o-animation-iteration-count: infinite;-o-animation-direction: alternate;-o-animation-play-state: running;&#125; 实例与上面的动画相同，但是使用了简写的动画 animation 属性： 12345678910div&#123;animation: myfirst 5s linear 2s infinite alternate;/* Firefox: */-moz-animation: myfirst 5s linear 2s infinite alternate;/* Safari 和 Chrome: */-webkit-animation: myfirst 5s linear 2s infinite alternate;/* Opera: */-o-animation: myfirst 5s linear 2s infinite alternate;&#125; CSS3 多列 通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！ 在本章中，您将学习如下多列属性： column-count column-gap column-rule Internet Explorer 10 和 Opera 支持多列属性。Firefox 需要前缀 -moz-。Chrome 和 Safari 需要前缀 -webkit-。注释： Internet Explorer 9 以及更早的版本不支持多列属性。 CSS3 创建多列column-count 属性规定元素应该被分隔的列数： 实例把 div 元素中的文本分隔为三列： 123456div&#123;-moz-column-count:3; /* Firefox */-webkit-column-count:3; /* Safari 和 Chrome */column-count:3;&#125; CSS3 规定列之间的间隔column-gap 属性规定列之间的间隔： 实例规定列之间 40 像素的间隔： 123456div&#123;-moz-column-gap:40px; /* Firefox */-webkit-column-gap:40px; /* Safari 和 Chrome */column-gap:40px;&#125; CSS3 列规则column-rule 属性设置列之间的宽度、样式和颜色规则。 实例规定列之间的宽度、样式和颜色规则： 123456div&#123;-moz-column-rule:3px outset #ff0000; /* Firefox */-webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */column-rule:3px outset #ff0000;&#125; CSS3 用户界面在 CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。 在本章中，您将学到以下用户界面属性： resize box-sizing outline-offset Firefox、Chrome 以及 Safari 支持 resize 属性。Internet Explorer、Chrome、Safari 以及 Opera 支持 box-sizing 属性。Firefox 需要前缀 -moz-。所有主流浏览器都支持 outline-offset 属性，除了 Internet Explorer。 CSS3 Resizing在 CSS3，resize 属性规定是否可由用户调整元素尺寸。 CSS 代码如下： 实例规定 div 元素可由用户调整大小： 12345div&#123;resize:both;overflow:auto;&#125; CSS3 Box Sizingbox-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。 实例规定两个并排的带边框方框： 12345678div&#123;box-sizing:border-box;-moz-box-sizing:border-box; /* Firefox */-webkit-box-sizing:border-box; /* Safari */width:50%;float:left;&#125; CSS3 Outline Offsetoutline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 轮廓与边框有两点不同： 轮廓不占用空间 轮廓可能是非矩形 CSS 代码如下： 实例规定边框边缘之外 15 像素处的轮廓： 123456div&#123;border:2px solid black;outline:2px solid red;outline-offset:15px;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON入门]]></title>
    <url>%2F2018%2F04%2F15%2FJSON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JSON：JavaScript 对象表示法（JavaScript Object Notation）。 JSON 是存储和交换文本信息的语法。类似 XML。 JSON 比 XML 更小、更快，更易解析。 12345678&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125;]&#125;这个 employee 对象是包含 3 个员工记录（对象）的数组。 什么是 JSON ？ JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言(JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。) JSON 具有自我描述性，更易理解 JSON - 转换为 JavaScript 对象JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。 由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval( ) 函数，用 JSON 数据来生成原生的 JavaScript 对象。 类似 XML JSON 是纯文本 JSON 具有“自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输 相比 XML 的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 为什么使用 JSON？对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 用 eval() 处理 JSON 字符串 JSON 语法是 JavaScript 语法的子集。 JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 名称/值对 JSON 数据的书写格式是：名称/值对。 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： 1&quot;firstName&quot; : &quot;John&quot; 这很容易理解，等价于这条 JavaScript 语句： 1firstName = &quot;John&quot; JSON 值JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON 对象 JSON 对象在花括号中书写： 对象可以包含多个名称/值对： 1&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125; 这一点也容易理解，与这条 JavaScript 语句等价： 12firstName = &quot;John&quot;lastName = &quot;Doe&quot; JSON 数组 JSON 数组在方括号中书写： 数组可包含多个对象： 1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。 JSON 使用 JavaScript 语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： 例子 12345var employees = [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项： 1employees[0].lastName; 返回的内容是： 1Gates 可以像这样修改数据： 1employees[0].lastName = &quot;Jobs&quot;; JSON 文件JSON 文件的文件类型是 “.json”JSON 文本的 MIME 类型是 “application/json” 把 JSON 文本转换为 JavaScript 对象 JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。 为了更简单地为您讲解，我们使用字符串作为输入进行演示（而不是文件）。 JSON 实例 - 来自字符串的对象 创建包含 JSON 语法的 JavaScript 字符串： 1234var txt = &apos;&#123; &quot;employees&quot; : [&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125; ]&#125;&apos;; 由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。 eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误： 1var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); 在网页中使用 JavaScript 对象： 例子 123456789&lt;p&gt;First Name: &lt;span id=&quot;fname&quot;&gt;&lt;/span&gt;&lt;br /&gt;Last Name: &lt;span id=&quot;lname&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&quot;fname&quot;).innerHTML = obj.employees[1].firstNamedocument.getElementById(&quot;lname&quot;).innerHTML = obj.employees[1].lastName&lt;/script&gt; JSON 解析器 提示：eval() 函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。 使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本，而不会编译脚本。 在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。 较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5知识点汇总]]></title>
    <url>%2F2018%2F04%2F15%2FHTML5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[注：本博客版权为W3Cschool所有。这篇博客的诞生的原因是学习的时候习惯性的写成了博客。 HTML5教程 HTML5 是 W3C 与 WHATWG 合作的结果。 W3C 指 World Wide Web Consortium，万维网联盟。 WHATWG 指 Web Hypertext Application Technology Working Group。 WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。 为 HTML5 建立的一些规则： 新特性应该基于 HTML、CSS、DOM 以及 JavaScript。 减少对外部插件的需求（比如 Flash） 更优秀的错误处理 更多取代脚本的标记 HTML5 应该独立于设备 开发进程应对公众透明 新特性 HTML5 中的一些有趣的新特性： 用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 对本地离线存储的更好的支持 新的特殊内容元素，比如 article、footer、header、nav、section 新的表单控件，比如 calendar、date、time、email、url、search 一、HTML5 视频当前，video 元素支持三种视频格式： 格式 IE Firefox Opera Chrome Safari Ogg NO 3.5+ 10.5+ 5.0+ NO MPEG4 9.0+ NO NO 5.0+ 3.0+ WebM NO 4.0+ 10.6+ 6.0+ NO Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件 MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件 WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件 视频工作 controls 属性供添加播放、暂停和音量控件。 包含宽度和高度属性也是不错的主意。 12345&lt;video&gt; 与 &lt;/video&gt; 之间插入的内容是供不支持 video 元素的浏览器显示的：&lt;video src=&quot;movie.ogg&quot; width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 上面的例子使用一个 Ogg 文件，适用于Firefox、Opera 以及 Chrome 浏览器。 要确保适用于 Safari 浏览器，视频文件必须是 MPEG4 类型。 video 元素允许多个 source 元素。source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式： 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 注：Internet Explorer 8 不支持 video 元素。在 IE 9 中，将提供对使用 MPEG4 的 video 元素的支持。 HTML &lt;video&gt; 标签 HTML5 &lt;video&gt; - 使用 DOM 进行控制 HTML5 &lt;video&gt; 元素同样拥有方法、属性和事件。 其中的方法用于播放、暂停以及加载等。其中的属性（比如时长、音量等）可以被读取或设置。其中的 DOM 事件能够通知您，比方说，&lt;video&gt; 元素开始播放、已暂停，已停止，等等。 HTML5 &lt;video&gt; - 方法、属性以及事件 注释：在所有属性中，只有 videoWidth 和 videoHeight 属性是立即可用的。在视频的元数据已加载后，其他属性才可用。 二、HTML5 音频Web 上的音频直到现在，仍然不存在一项旨在网页上播放音频的标准。 今天，大多数音频是通过插件（比如 Flash）来播放的。然而，并非所有浏览器都拥有同样的插件。 HTML5 规定了一种通过 audio 元素来包含音频的标准方法。 audio 元素能够播放声音文件或者音频流。 音频格式当前，audio 元素支持三种音频格式： 如何工作 如需在 HTML5 中播放音频，您所有需要的是： 12&lt;audio src=&quot;song.ogg&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; control 属性供添加播放、暂停和音量控件。 与 之间插入的内容是供不支持 audio 元素的浏览器显示的：实例 123&lt;audio src=&quot;song.ogg&quot; controls=&quot;controls&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; 上面的例子使用一个 Ogg 文件，适用于Firefox、Opera 以及 Chrome 浏览器。 要确保适用于 Safari 浏览器，音频文件必须是 MP3 或 Wav 类型。 audio 元素允许多个 source 元素。source 元素可以链接不同的音频文件。浏览器将使用第一个可识别的格式： 实例 12345&lt;audio controls=&quot;controls&quot;&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; Internet ExplorerInternet Explorer 8 不支持 audio 元素。在 IE 9 中，将提供对 audio 元素的支持。 &lt;audio&gt; 标签的属性 三、HTML 5 拖放拖放（Drag 和 drop）是 HTML5 标准的组成部分。 拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置。 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 浏览器支持Internet Explorer 9、Firefox、Opera 12、Chrome 以及 Safari 5 支持拖放。 注释：在 Safari 5.1.2 中不支持拖放。 HTML5 拖放实例下面的例子是一个简单的拖放实例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function allowDrop(ev)&#123;ev.preventDefault();&#125;function drag(ev)&#123;ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125;function drop(ev)&#123;ev.preventDefault();var data=ev.dataTransfer.getData(&quot;Text&quot;);ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot;ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot;ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 它看上去也许有些复杂，不过我们可以分别研究拖放事件的不同部分。 设置元素为可拖放首先，为了使元素可拖动，把 draggable 属性设置为 true ： 1&lt;img draggable=&quot;true&quot; /&gt; 拖动什么 - ondragstart 和 setData()然后，规定当元素被拖动时，会发生什么。 在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。 dataTransfer.setData() 方法设置被拖数据的数据类型和值： 1234function drag(ev)&#123;ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; 在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。 放到何处 - ondragover ondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： 1event.preventDefault() 进行放置 - ondrop当放置被拖数据时，会发生 drop 事件。在上面的例子中，ondrop 属性调用了一个函数，drop(event)： 123456function drop(ev)&#123;ev.preventDefault();var data=ev.dataTransfer.getData(&quot;Text&quot;);ev.target.appendChild(document.getElementById(data));&#125; 代码解释： 调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 被拖数据是被拖元素的 id (“drag1”) 把被拖元素追加到放置元素（目标元素）中 四、HTML 5 Canvascanvas 元素用于在网页上绘制图形。 什么是 Canvas？ HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域，您可以控制其每一像素。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建 Canvas 元素向 HTML5 页面添加 canvas 元素。 规定元素的 id、宽度和高度： 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 通过 JavaScript 来绘制canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成： 123456&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var cxt=c.getContext(&quot;2d&quot;);cxt.fillStyle=&quot;#FF0000&quot;;cxt.fillRect(0,0,150,75);&lt;/script&gt; JavaScript 使用 id 来寻找 canvas 元素： 1var c=document.getElementById(&quot;myCanvas&quot;); 然后，创建 context 对象： 1var cxt=c.getContext(&quot;2d&quot;); getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 下面的两行代码绘制一个红色的矩形： 12cxt.fillStyle=&quot;#FF0000&quot;;cxt.fillRect(0,0,150,75); fillStyle 方法将其染成红色，fillRect 方法规定了形状、位置和尺寸。 理解坐标上面的 fillRect 方法拥有参数 (0,0,150,75)。 意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 如下例所示，画布的 X 和 Y 坐标用于在画布上对绘画进行定位。 实例 HTML 5 Canvas 参考手册 五、HTML5 内联 SVG什么是SVG？ SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用于定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG 是万维网联盟的标准 SVG 的优势与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于： SVG 图像可通过文本编辑器来创建和修改 SVG 图像可被搜索、索引、脚本化或压缩 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 可以与 Java 技术一起运行 SVG 是开放的标准 SVG 文件是纯粹的 XML 浏览器支持Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持内联 SVG。 把 SVG 直接嵌入 HTML 页面在 HTML5 中，您能够将 SVG 元素直接嵌入 HTML 页面中： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt; &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 六、HTML 5 Canvas vs. SVGCanvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。 SVGSVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 CanvasCanvas 通过 JavaScript 来绘制 2D 图形。 Canvas 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较下表列出了 canvas 与 SVG 之间的一些不同之处。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 七、HTML5 地理定位定位用户的位置HTML5 Geolocation API 用于获得用户的地理位置。 鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。 浏览器支持Internet Explorer 9、Firefox、Chrome、Safari 以及 Opera 支持地理定位。 注释：对于拥有 GPS 的设备，比如 iPhone，地理定位更加精确。 HTML5 - 使用地理定位请使用 getCurrentPosition() 方法来获得用户的位置。 下例是一个简单的地理定位实例，可返回用户位置的经度和纬度。 12345678910111213141516&lt;script&gt;var x=document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else&#123;x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;&#125; &#125;function showPosition(position) &#123; x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude; &#125;&lt;/script&gt; 例子解释： 检测是否支持地理定位 如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。 如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象 showPosition() 函数获得并显示经度和纬度 上面的例子是一个非常基础的地理定位脚本，不含错误处理。 处理错误和拒绝 getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数： 123456789101112131415161718function showError(error) &#123; switch(error.code) &#123; case error.PERMISSION_DENIED: x.innerHTML=&quot;User denied the request for Geolocation.&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML=&quot;Location information is unavailable.&quot; break; case error.TIMEOUT: x.innerHTML=&quot;The request to get user location timed out.&quot; break; case error.UNKNOWN_ERROR: x.innerHTML=&quot;An unknown error occurred.&quot; break; &#125; &#125; 错误代码： Permission denied - 用户不允许地理定位 Position unavailable - 无法获取当前位置 Timeout - 操作超时 在地图中显示结果如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图： 实例 123456789function showPosition(position)&#123;var latlon=position.coords.latitude+&quot;,&quot;+position.coords.longitude;var img_url=&quot;http://maps.googleapis.com/maps/api/staticmap?center=&quot;+latlon+&quot;&amp;zoom=14&amp;size=400x300&amp;sensor=false&quot;;document.getElementById(&quot;mapholder&quot;).innerHTML=&quot;&lt;img src=&apos;&quot;+img_url+&quot;&apos; /&gt;&quot;;&#125; 在上例中，我们使用返回的经纬度数据在谷歌地图中显示位置（使用静态图像）。 给定位置的信息本页演示的是如何在地图上显示用户的位置。不过，地理定位对于给定位置的信息同样很有用处。 案例： 更新本地信息 显示用户周围的兴趣点 交互式车载导航系统 (GPS) getCurrentPosition() 方法 - 返回数据若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。 Geolocation 对象 - 其他有趣的方法watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。 clearWatch() - 停止 watchPosition() 方法 下面的例子展示 watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）： 实例 12345678910111213141516&lt;script&gt;var x=document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.watchPosition(showPosition); &#125; else&#123;x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;&#125; &#125;function showPosition(position) &#123; x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude; &#125;&lt;/script&gt; 八、HTML 5 Web 存储 在客户端存储数据HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。 HTML5 使用 JavaScript 来存储和访问数据。 localStorage 方法localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 如何创建和访问 localStorage： 实例 1234&lt;script type=&quot;text/javascript&quot;&gt;localStorage.lastname=&quot;Smith&quot;;document.write(localStorage.lastname);&lt;/script&gt; 下面的例子对用户访问页面的次数进行计数：实例 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;if (localStorage.pagecount) &#123; localStorage.pagecount=Number(localStorage.pagecount) +1; &#125;else &#123; localStorage.pagecount=1; &#125;document.write(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;);&lt;/script&gt; sessionStorage 方法sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 如何创建并访问一个 sessionStorage： 实例 1234&lt;script type=&quot;text/javascript&quot;&gt;sessionStorage.lastname=&quot;Smith&quot;;document.write(sessionStorage.lastname);&lt;/script&gt; 下面的例子对用户在当前 session 中访问页面的次数进行计数： 实例 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;if (sessionStorage.pagecount) &#123; sessionStorage.pagecount=Number(sessionStorage.pagecount) +1; &#125;else &#123; sessionStorage.pagecount=1; &#125;document.write(&quot;Visits &quot;+sessionStorage.pagecount+&quot; time(s) this session.&quot;);&lt;/script&gt; 九、HTML 5 应用程序缓存 使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。 什么是应用程序缓存（Application Cache）？HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 浏览器支持所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。 HTML5 Cache Manifest 实例下面的例子展示了带有 cache manifest 的 HTML 文档（供离线浏览）： 实例 12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt;&lt;body&gt;The content of the document......&lt;/body&gt;&lt;/html&gt; Cache Manifest 基础如需启用应用程序缓存，请在文档的 标签中包含 manifest 属性： 1234&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt;...&lt;/html&gt; 每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。 manifest 文件的建议的文件扩展名是：”.appcache”。 请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） CACHE MANIFEST第一行，CACHE MANIFEST，是必需的： 1234CACHE MANIFEST/theme.css/logo.gif/main.js 上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。 NETWORK下面的 NETWORK 小节规定文件 “login.asp” 永远不会被缓存，且离线时是不可用的： 12NETWORK:login.asp 可以使用星号来指示所有其他资源/文件都需要因特网连接： 123NETWORK:*FALLBACK 下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html5/ 目录中的所有文件： FALLBACK:/html5/ /404.html注释：第一个 URI 是资源，第二个是替补。 更新缓存 一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改（参阅下面的提示） 由程序来更新应用缓存 实例 - 完整的 Manifest 文件 1234567891011CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.aspFALLBACK:/html5/ /404.html 重要的提示：以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 关于应用程序缓存的注释 请留心缓存的内容。 一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。 注释：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 十、HTML 5 Web Workersweb worker 是运行在后台的 JavaScript，不会影响页面的性能。 什么是 Web Worker？ 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 浏览器支持所有主流浏览器均支持 web worker，除了 Internet Explorer。 检测 Web Worker 支持在创建 web worker 之前，请检测用户的浏览器是否支持它： 123456789if(typeof(Worker)!==&quot;undefined&quot;) &#123; // Yes! Web worker support! // Some code..... &#125;else &#123; // Sorry! No Web Worker support.. &#125; 创建 web worker 文件 现在，让我们在一个外部 JavaScript 中创建我们的 web worker。 在这里，我们创建了计数脚本。该脚本存储于 “demo_workers.js” 文件中： 12345678910var i=0;function timedCount()&#123;i=i+1;postMessage(i);setTimeout(&quot;timedCount()&quot;,500);&#125;timedCount(); 以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。 注释：web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。 创建 Web Worker 对象 我们已经有了 web worker 文件，现在我们需要从 HTML 页面调用它。 下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码： 1234if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; 然后我们就可以从 web worker 发生和接收消息了。 向 web worker 添加一个 “onmessage” 事件监听器： 123w.onmessage=function(event)&#123;document.getElementById(&quot;result&quot;).innerHTML=event.data;&#125;; 当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。 终止 Web Worker 当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。 如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法： 1w.terminate(); 完整的 Web Worker 实例代码 我们已经看到了 .js 文件中的 Worker 代码。下面是 HTML 页面的代码： 实例 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt;&lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;&lt;script&gt;var w;function startWorker()&#123;if(typeof(Worker)!==&quot;undefined&quot;)&#123; if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function (event) &#123; document.getElementById(&quot;result&quot;).innerHTML=event.data; &#125;;&#125;else&#123;document.getElementById(&quot;result&quot;).innerHTML=&quot;Sorry, your browser does not support Web Workers...&quot;;&#125;&#125;function stopWorker()&#123;w.terminate();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Web Workers 和 DOM 由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象： window 对象 document 对象 parent 对象 十一、HTML 5 服务器发送事件HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。 Server-Sent 事件 - 单向消息传递 Server-Sent 事件指的是网页自动获取来自服务器的更新。 以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。 例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等。 浏览器支持所有主流浏览器均支持服务器发送事件，除了 Internet Explorer。 接收 Server-Sent 事件通知EventSource 对象用于接收服务器发送事件通知： 实例 12345var source=new EventSource(&quot;demo_sse.php&quot;);source.onmessage=function(event) &#123; document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; &#125;; 例子解释： 创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”） 每接收到一次更新，就会发生 onmessage 事件 当 onmessage 事件发生时，把已接收的数据推入 id 为 “result” 的元素中 检测 Server-Sent 事件支持 在上面的 TIY 实例中，我们编写了一段额外的代码来检测服务器发送事件的浏览器支持情况： 123456789if(typeof(EventSource)!==&quot;undefined&quot;) &#123; // Yes! Server-sent events support! // Some code..... &#125;else &#123; // Sorry! No server-sent events support.. &#125; 服务器端代码实例为了让上面的例子可以运行，您还需要能够发送数据更新的服务器（比如 PHP 和 ASP）。 服务器端事件流的语法是非常简单的。把 “Content-Type” 报头设置为 “text/event-stream”。现在，您可以开始发送事件流了。 PHP 代码 (demo_sse.php)： 123456789101112131415&lt;?phpheader(&apos;Content-Type: text/event-stream&apos;);header(&apos;Cache-Control: no-cache&apos;);$time = date(&apos;r&apos;);echo &quot;data: The server time is: &#123;$time&#125;\n\n&quot;;flush();?&gt;ASP 代码 (VB) (demo_sse.asp):&lt;%Response.ContentType=&quot;text/event-stream&quot;Response.Expires=-1Response.Write(&quot;data: &quot; &amp; now())Response.Flush()%&gt; 代码解释： 把报头 “Content-Type” 设置为 “text/event-stream” 规定不对页面进行缓存 输出发送日期（始终以 “data: “ 开头） 向网页刷新输出数据 EventSource 对象 在上面的例子中，我们使用 onmessage 事件来获取消息。不过还可以使用其他事件：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript思维导图]]></title>
    <url>%2F2018%2F04%2F11%2FJavaScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图源于W3Cschool 一、数据类型 二、变量 三、运算符 四、流程语句 五、数组 六、函数基础 七、字符串函数 八、正则表达式 九、DOM基本操作 十、window对象]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试技巧总结（IMOOC）]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[该博客总结慕课网-快乐动起来呀老师的前端面试技巧，还请读者跳转到课程主页购买观看。 关于面试 技术面试（技术方面） 负责人面试（技术、项目深度、项目架构、业务） HR面试（性格、沟通、潜力） 大概1-1.5小时 五大部分1、面试准备2、面试技巧3、题目演练4、知识梳理5、复习指导课程价值： JD描述怎看 奖励怎么写 知识怎么复习 问题该怎么回答 项目怎么准备 和负责人怎么沟通 HR印象怎么留 课程安排面试准备 JD描述分析 ！业务分析 技术栈准备 自我介绍 模拟1面 面试技巧 页面布局类 CSS盒模型 DOM事件类 HTTP协议类 原型链类 面向对象类 通信类 前端安全 前端算法类 模拟2面 面试技巧 渲染机制 JS运行机制 页面性能 错误监控 模拟3面 面试技巧 业务能力 团队协作能力 带人能力 模拟终面 面试技巧 职业竞争力 职业规划 课程总结 注意事项 复习指南 面试模拟与技巧1、如何看待面试 我：考察面试者的基本能力 校招：偏重于校园学到的知识和能力 社招：能力=工作知识+工作经验 2、面试环节 一面：基础知识 二面/三面：基础的延伸、引导面试官 三面/四面：业务负责人–业务能力（校招一般没有） HR面：认真面对 面试准备1、职位描述（JD）分析 真正分析所面公司的职位描述（基本功-难度） 工作经验不会卡的太厉害还是看技术 准备所面公司用的技术栈 初衷 1、快速识别喜不喜欢这个岗位 2、能不能hold住这个岗位 2、业务分析或实战模拟 分析面试公司官方网站 微信小程序 3、技术栈准备 jQuery （源码：核心架构、事件委托、插件机制、兼容性） Vue（推荐！分析后的源码博客、阅读量大的） React（推荐！） Angular Node.js（花太久） 时间紧准备一个 最好有实战（遇到的问题、如何解决问题） 以上一种 一下一种 gulp（推荐） Sass less (两种预编译语言)npm grunt browserify webpack 准备所面公司用的技术 4、自我介绍简历 基本信息，姓名-年龄-手机-邮箱-籍贯 学历，博士》硕士》本科》大专 工作经历，时间-公司-岗位-职责-技术栈-业绩 开源项目，Github和说明（找开源项目、参与开源项目） 1、教育背景 2、学习经历 3、个人技能 4、工作经历自我陈述 把握面试的沟通方向 比如说喜欢研究什么网站 经常在那些网站上活跃 豁达、自信的适度发挥 自信、适度、谦虚 目的是让面试官欣赏你 实例（面试要的是你比别人聪明） 自如谈兴趣、巧妙示实例、适时讨疑问（不会就不会，但一定要以谦虚询问为结束：我该看什么资料了解这些知识，向面试官寻求资料） 节奏要适宜、切忌小聪明（多种方法解决问题会直接提升印象） 实践 方向要对，过程要细 胆子要大，心态要和 一面/二面面试技巧 准备要充分 知识要系统 沟通要简洁 内心要诚实 态度要谦虚 回答要灵活 面试模拟 一、页面布局题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各位300px，中间自适应。 1、题目真的这么简单吗（浮动、定位、Flexbox、表格布局、网格布局）2、这道题难点技巧在哪里3、这道题怎么拔高、延伸 解决方案 1、浮动（兼容性好、但脱离文档流）2、绝对定位（快速解决、之后元素脱离文档流）3、Flexbox（解决上两个方法的布局、先用最多）4、表格布局（兼容性很好、繁琐？）5、网格布局（H5新技术） 文字过多的话用3、4，不会超出范围 页面布局的变通 三栏布局 左右宽度固定，中间自适应 上下高度固定，中间自适应 两栏布局 左宽度固定，右自适应 右宽度固定，左自适应 上宽度固定，下自适应 下宽度固定，上自适应 页面布局总结 语义化掌握到位 页面布局理解深刻 CSS基础知识扎实 思维灵活且积极上进 代码书写规范 二、CSS盒模型基本概念：标准模型+IE模型标准模型和IE模型的区别 CSS如何设置两种模型 box-sizing:content-box;(默认：标准模型) box-sizing:border-box;(IE模型) JS如何设置获取盒模型对应的宽和高 dom.style.width/height dom.currentStyle.width/height window.getComputedStyle(dom).width/height dom.getBoundingClientRect().width/height 实例题（根据盒模型解释边距重叠）box.html BFC（边距重叠解决方案） BFC的基本概念：块级格式化上下文 BFC的原理：1、BFC的垂直方向会发生重叠2、BFC的区域不会与浮动元素的box重叠3、BFC是一个独立的容器，外面的元素不会影响里面的元素，反之亦然4、计算BFC高度的时候，浮动元素也会计算 如何创建BFC1、float值不为none2、position只要不是static或relative就是BFC3、display属性4、overflow BFC使用场景code： 三、DOM事件基本概念：DOM事件的级别 DOM0 element.onclick=function(){}DOM2 element.addEventListener(‘click’,function(){},false)DOM3 element.addEventListener(‘kepup’,function(){},false) DOM事件模型 捕获冒泡 DOM事件流1、捕获2、目标阶段3、冒泡 描述DOM事件捕获的具体流程 冒泡的具体流程就是倒过来 Event对象的常见应用 自定义事件code:event.html 四、HTTP协议类HTTP协议的主要特点 简单快速 灵活 无连接 无状态 HTTP报文的组成部分 HTTP方法 POST和GET的区别(重要！) HTTP状态码 什么是持久连接（打电话一个一个打还是一直通着） HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求和应答都要新建一个连接，完成后立即断开连接（HTTP协议为无连接的协议）当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的链接持续有效，当出现对服务器的后继请求时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 什么是管线化（请求打包发出-响应打包返回） 在使用持久连接的情况下，某个连接上消息的传递类似于：请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3 某个连接上的消息变成了类似这样：（请求打包发出-响应打包返回）请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3 管线化特点: 五、原型链类 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new运算符 面向对象类(oop.html) 类与实例 类的声明 生成实例 类与继承 如何实现继承 继承的几种方式!!! 通信类什么是同源策略限制（3个） 前后端如何通信（Ajax+。。。。一个不合格） Ajax WebSocket CORS 如何创建Ajax XMLHttpRequest对象的工作流程 兼容性处理 事件的出发条件 事件的触发顺序 跨域通信的几种方式!!! JSONP（原理、怎么实现的） Hash postMessage(H5) WebSocket CORS(新标准) 安全类CSRF 基本概念和缩写 通常称为跨站请求伪造，英文名Cross-site request forgery 攻击原理 防御措施 Token验证 Referer验证 隐藏令牌 XSS 基本概念和缩写 cross-site scripting(跨域脚本 攻击) 攻击原理 防御措施 Token验证 Referer验证 隐藏令牌 WEB安全之XSS 算法类 排序！ 快速排序 选择排序 希尔排序 堆栈！、队列、链表 递归！ 递归 波兰式和逆波兰式 理论 源码 二面/三面面试技巧 知识面要广 理解要深刻 内心要诚实 态度要谦虚 回答要灵活 要学会赞美 面试模拟 渲染机制类 什么是DOCTYPE 浏览器渲染过程 重排Reflow 定义 DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。 触发Reflow 当你增加、删除、修改DOM结点时，会导致Reflow或Repaint 当你移动DOM的位置时，或者搞个动画的时候 当你修改CSS样式的时候 当你Resize窗口的时候（移动端没有这个问题），或者是滚动的时候 当你修改网页的默认字体时 重绘Repaint 定义 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为Repaint。 大白话:页面要呈现的内容，统统的画在屏幕上。 触发Repaint DOM改动 CSS改动 如何尽量减少Repaint 布局Layout 运行机制类 JavaScript 运行机制详解 如何理解JS的单线程 JS是单线程的，同一时间只能做一件事。 异步任务（队列）要挂起，先做同步任务，处理过后才相应异步任务。 12345678例一、 console.log(&apos;1&apos;); setTimeout(function()&#123; console.log(3); &#125;,0); console.log(&apos;2&apos;); 结果：1、2、3. 123456789例二、 console.log(&apos;A&apos;); while(true)&#123; &#125; console.log(&apos;B&apos;); 结果：A。 因为while是同步任务，一直在执行. 123456789101112例三、 for(var i=0;i&lt;4;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000); &#125; 结果：4、4、4、4. 因为for循环是同步任务， 所以执行for循环的时候setTimeout()函数是存在定时器中的， 并没有执行，一直到for循环执行结束后setTimeout()函数才开始执行 ---异步任务的放入队列的时间和执行时间 什么是任务队列 JavaScript 异步、栈、事件循环、任务队列 JavaScript：彻底理解同步、异步和事件循环(Event Loop) 什么是Event Loop Event Loop的规范和实现 从一道题浅说 JavaScript 的事件循环 异步任务 setTimeout和setInterval DOM事件 ES6中的Promise 总结 理解JS的单线程的概念 理解任务队列 理解Event Loop 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能类 江湖失传的最后一份CDN秘籍 异步加载 浏览器缓存 缓存的分类（会问协议头中关于缓存的字段） 强缓存(本地有缓存，不向服务器询问，直接使用缓存) Exporis（服务器的绝对时间，下发资源的时间） Cache-Control : max-age=3600（相对时间、拿到资源之后3600s之内直接使用本地资源。若两个时间都有，以Cache-Control为准） 协商缓存（和服务器协商） Last-Modified（服务器下发的） If-Modified-Since（再次请求时发出的，两值相等） Etag （哈希值，服务器第一次下发资源的时候给的，过了强缓存时间后） If-None-Match（请求时加的值，=Etag） 错误监控类 前端错误的分类 即时运行错误 try..catch window.onerror 资源加载错误 object.onerror performance.getEntries() Error时间捕获 延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？ 错误的捕获方式 上报错误的基本原理 采用Ajax通信的方式上报 利用Image对象上报 三面/四面面试技巧 准备要充分 描述要熟练 引导找时机 优势要发挥 回答要灵活 考察点 业务能力 团队协作能力 事务推动能力 带人能力 其他能力 主动描述、被动回答 我做过什么业务 独立负责。。。 负责的业务有什么业绩 历时。。。完成。。。，用户量上涨。。。 使用了什么技术方案 区别常规。。。，使用了。。。方案 突破了什么技术难点 解决了。。。 遇到了什么问题 。。。 最大的收获是什么 对业务的理解更加深入、对技术图表更有把控 团队协作能力 主动描述 协助。。。和。。。快速开发。。。 结论 一定要准备小项目！！！ 事务推动能力 主动描述 例子： 对历史算法更新换代 推动专题的CMS架构 主导克服系统的建设 完成多项专利的申请 终面面试技巧 乐观积极 主动沟通 逻辑顺畅 上进有责任心 有主张，做事果断 职业竞争力（准备好） 业务能力 可以做到行业第一 思考能力 对同一件事情可以从不同角度去思考，找到最优解 学习能力 不断学习新的业务和技术，沉淀、总结 无上限的付出 对于无法解决的问题可以熬夜、加班 职业规划（准备好） 目标是什么 在业务上成为专家，在技术上成为行业大牛 近阶段的目标 不断的学习积累各方面的经验，以学习为主 长期目标 做几件很有价值的事情，如开源作品、技术框架等 方式方法 先完成业务上的主要问题，做到极致，然后逐步向目标靠拢 课程总结 JD描述 对社招一定要看，对于校招可以忽略 简历 对照JD该写出相吻合的简历，对于未掌握的技术栈快速复习、理解 自我介绍 一定要打草稿，展示什么优势、描述什么项目，切忌临场发挥 一面 重基础、懂原理、要思考、知进退、势不可挡 二面 横向扩展、项目结合、做到有的放矢 三面 有经验、懂合作、有担当、懂规律、察言观色 终面 会沟通、要上进、好性格、有主见、强逻辑、无可挑剔 复盘 胜不骄、败不馁、总结经验、步步为营、多拿几个offer 复习指南课程中主要涉及的重点、难点，对于一些很基础的知识点没有涉及，如css选择器、HTML标签等等 对于很基础的知识点，大家可以参考W3C，把HTML、HTML5、CSS、CSS3、JavaScript等再快速看一遍，有基础的同学估计两天就能都过一遍 对于算法题，每个公司都是临时发挥，很难押题，建议还是把一些基础算法弄清楚、到时候把算法组合起来去解决问题，时间充裕的话可以刷LeetCode 堆栈、队列、链表]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CART-分类回归树]]></title>
    <url>%2F2018%2F04%2F09%2FCART-%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BD%92%E6%A0%91%2F</url>
    <content type="text"><![CDATA[CART（Classification And Regression Trees，分类回归树）算法，CART是一个独立于其他经典决策树算法的算法，所以导致CART相对来说较为复杂。因为它不仅仅可以作为分类树，还可以作为回归树。采用的是Gini指数（选Gini指数最小的特征s）作为分裂标准,同时它也是包含后剪枝操作。ID3算法和C4.5算法虽然在对训练样本集的学习中可以尽可能多地挖掘信息，但其生成的决策树分支较大，规模较大。为了简化决策树的规模，提高生成决策树的效率，就出现了根据GINI系数来选择测试属性的决策树算法CART。 一、基尼指数 定义：基尼指数（基尼不纯度）：表示在样本集合中一个随机选中的样本被分错的概率。 注意： Gini指数越小表示集合中被选中的样本被分错的概率越小，也就是说集合的纯度越高，反之，集合越不纯。 即 基尼指数（基尼不纯度）= 样本被选中的概率 * 样本被分错的概率 公式说明 pk表示选中的样本属于k类别的概率，则这个样本被分错的概率是(1-pk) 样本集合中有K个类别，一个随机选中的样本可以属于这k个类别中的任意一个，因而对类别就加和 当为二元切分法时，Gini(P) = 2p(1-p)，它易于对树构建过程进行调整以处理连续性特征。 二、基于特征A划分样本集合D之后的基尼指数需要说明的是CART是个二叉树，也就是当使用某个特征划分样本集合只有两个集合：1. 等于给定的特征值的样本集合D1 ， 2.不等于给定的特征值的样本集合D2实际上是对拥有多个取值的特征的二值处理。举个栗子🌰： 假设现在有特征 “学历”，此特征有三个特征取值： “本科”，“硕士”， “博士”， 当使用“学历”这个特征对样本集合D进行划分时，划分值分别有三个，因而有三种划分的可能集合，划分后的子集如下：1. 划分点： “本科”，划分后的子集合 ： {本科}，{硕士，博士}2. 划分点： “硕士”，划分后的子集合 ： {硕士}，{本科，博士}3. 划分点： “硕士”，划分后的子集合 ： {博士}，{本科，硕士}对于上述的每一种划分，都可以计算出基于 划分特征 = 某个特征值 将样本集合D划分为两个子集的纯度： 因而对于一个具有多个取值（超过2个）的特征，需要计算以每一个取值作为划分点，对样本D划分之后子集的纯度Gini(D,Ai)，(其中Ai 表示特征A的可能取值)然后从所有的可能划分的Gini(D,Ai)中找出Gini指数最小的划分，这个划分的划分点，便是使用特征A对样本集合D进行划分的最佳划分点。求基尼系数的含义：基尼系数宏观表达的是描述一个集合的混乱程度。基尼指数越大，表示这个样本集合D越混乱。这和熵的作用有些类似，但这仅仅是一个指数，能够判断大小，但不能像熵一样线性的量化集合中的混乱程度。——-三、CART分类生成算法 输入：训练数据集D，停止计算的条件；输出：CART决策树；根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树： 设结点的训练数据集为D，计算现有特征对该数据集的基尼指数。此时，对每一个特征A，对其可能取的每个值a，根据样本点对A=a的测试为“是”或“否”将D分割成D1和D2两部分，之后计算基尼指数。 在所有可能的特征A以及它们所有可能的切分点a中，选择基尼指数最小的特征及其对应的切分点作为最有特征与最优切分点。依照最优特征与最优切分点，从现有结点生成两个子节点，将训练数据集按照特征分配到两个子节点中去。 对两个子结点递归地调用两个子结点，将训练数据集按特征分配到两个子节点中去。 生成CART决策树。 下面用一个案例理解计算过程： 四、CART回归树算法CART生成回归树的算法是用来根据已有数据生成一个回归树，具体算法如下：这个算法比前面的那些算法要更加复杂一点，有很多公式。要想理解这个算法的作用，我们得先从感性上理解这个算法是做什么的。我们考虑最简单的最小二乘回归，CART要求我们将所有输入数据都当作在二维的平面上若干个数据点。以x轴为划分依据（也就是最后的回归树的分界线是x的值，x大于或小于某个值会判断成什么）。1. 先自己认定一组切分点（一般认为是两个点x值的中点）。然后计算这一组切分点中每一个切分点对应的均方误差，找到均方误差最小的那个切分点作为一个节点；2. 这个切分点已经将整个空间划为两块(我们只考虑最简单的二维，所以一个点代表一条垂直于x轴的线)，我们分别对这两块继续计算均方误差，找到下一个节点；3. 直到总的均方误差达到要求为止。举个栗子🌰：科普1.信息增益（ ID3算法 ） 定义： 以某特征划分数据集前后的熵的差值 在熵的理解那部分提到了，熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。划分前样本集合D的熵是一定的 ，entroy(前)，使用某个特征A划分数据集D，计算划分后的数据子集的熵 entroy(后)信息增益 = entroy(前) - entroy(后)公式: 做法：计算使用所有特征划分数据集D，得到多个特征划分数据集D的信息增益，从这些信息增益中选择最大的，因而当前结点的划分特征便是使信息增益最大的划分所使用的特征。 信息增益的理解： 对于待划分的数据集D，其 entroy(前)是一定的，但是划分之后的熵 entroy(后)是不定的，entroy(后)越小说明使用此特征划分得到的子集的不确定性越小（也就是纯度越高），因此 entroy(前) - entroy(后)差异越大，说明使用当前特征划分数据集D的话，其纯度上升的更快。而我们在构建最优的决策树的时候总希望能更快速到达纯度更高的集合，这一点可以参考优化算法中的梯度下降算法，每一步沿着负梯度方法最小化损失函数的原因就是负梯度方向是函数值减小最快的方向。同理：在决策树构建的过程中我们总是希望集合往最快到达纯度更高的子集合方向发展，因此我们总是选择使得信息增益最大的特征来划分当前数据集D。 缺点：信息增益偏向取值较多的特征 原因：当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此信息增益比较 偏向取值较多的特征。 2.信息增益比（ C4.5算法 ） 信息增益比 = 惩罚参数 * 信息增益公式： 注意：其中的HA(D)，对于样本集合D，将当前特征A作为随机变量（取值是特征A的各个特征值），求得的经验熵。（之前是把集合类别作为随机变量，现在把某个特征作为随机变量，按照此特征的特征取值对集合D进行划分，计算熵HA(D)） 信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。 惩罚参数：数据集D以特征A作为随机变量的熵的倒数，即：将特征A取值相同的样本划分到同一个子集中（之前所说数据集的熵是依据类别进行划分的） 缺点：信息增益比偏向取值较少的特征 原因：当特征取值较少时HA(D)的值较小，因此其倒数较大，因而信息增益比较大。因而偏向取值较少的特征。 使用信息增益比：基于以上缺点，并不是直接选择信息增益率最大的特征，而是现在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林]]></title>
    <url>%2F2018%2F03%2F15%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[简介:在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 Leo Breiman和Adele Cutler发展出推论出随机森林的算法。而”Random Forests”是他们的商标。这个术语是1995年由贝尔实验室的Tin Kam Ho所提出的随机决策森林（random decision forests）而来的。随机森林是通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。随机森林的名称中有两个关键词，一个是“随机”，一个就是“森林”。“森林”我们很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，这样的比喻还是很贴切的，其实这也是随机森林的主要思想–集成思想的体现。“随机”的含义我们会在下边部分讲到。 其实从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出，这就是一种最简单的 Bagging 思想。 理解：我们要将一个输入样本进行分类，我们需要将输入样本输入到每棵树中进行分类。打个形象的比喻：森林中召开会议，讨论某个动物到底是老鼠还是松鼠，每棵树都要独立地发表自己对这个问题的看法，也就是每棵树都要投票。该动物到底是老鼠还是松鼠，要依据投票情况来确定，获得票数最多的类别就是森林的分类结果。森林中的每棵树都是独立的，99.9%不相关的树做出的预测结果涵盖所有的情况，这些预测结果将会彼此抵消。少数优秀的树的预测结果将会超脱于芸芸“噪音”，做出一个好的预测。将若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器，这就是随机森林bagging的思想（关于bagging的一个有必要提及的问题：bagging的代价是不用单棵决策树来做预测，具体哪个变量起到重要作用变得未知，所以bagging改进了预测准确率但损失了解释性。）。 算法：根据下列算法而建造每棵树： 用N来表示训练用例（样本）的个数，M表示特征数目。 输入特征数目m，用于确定决策树上一个节点的决策结果；其中m应远小于M。 从N个训练用例（样本）中以有放回抽样的方式，取样N次，形成一个训练集（即bootstrap取样），并用未抽到的用例（样本）作预测，评估其误差。 对于每一个节点，随机选择m个特征，决策树上每个节点的决定都是基于这些特征确定的。根据这m个特征，计算其最佳的分裂方式。 每棵树都会完整成长而不会剪枝（Pruning，这有可能在建完一棵正常树状分类器后会被采用）。 随机森林的生成方法： 1.从样本集中通过重采样的方式产生n个样本 2.假设样本特征数目为a，对n个样本选择a中的k个特征，用建立决策树的方式获得最佳分割点 3.重复m次，产生m棵决策树 4.多数投票机制来进行预测 （需要注意的一点是，这里m是指循环的次数，n是指样本的数目，n个样本构成训练的样本集，而m次循环中又会产生m个这样的样本集） 优点:随机森林的优点有： 对于很多种数据，它可以产生高准确度的分类器。 它可以处理大量的输入变量。 它可以在决定类别时，评估变量的重要性。 在建造森林时，它可以在内部对于一般化后的误差产生不偏差的估计。 它包含一个好方法可以估计丢失的数据，并且，如果有很大一部分的数据丢失，仍可以维持准确度。 它提供一个实验方法，可以去侦测variable interactions。 对于不平衡的分类数据集来说，它可以平衡误差。 它计算各例中的亲近度，对于数据挖掘、侦测离群点（outlier）和将数据可视化非常有用。 使用上述。它可被延伸应用在未标记的数据上，这类数据通常是使用非监督式聚类。也可侦测偏离者和观看数据。 学习过程是很快速的。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入音乐视频]]></title>
    <url>%2F2018%2F03%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[随着自己在重新整理自己博客的探索中越来越深入，各种有趣的小功能越来越让我感到有趣，所以我整理了一下在文章中插入视频音乐的方法 安装插件安装hexo-tag-aplayer和hexo-tag-dplayer插件 进入站点文件夹根目录,之后安装插件 123cd blognpm install hexo-tag-aplayer --savenpm install hexo-tag-dplayer --save Hexo音乐插件详细信息：hexo-tag-aplayer中文文档真.源码：APlayerHexo视频插件纤细信息：hexo-tag-dplayer文档在文章中的用法:当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： {% aplayer "Caffeine" "Jeff Williams" "caffeine.mp3" "picture.jpg" "lrc:caffeine.txt" %} 示例：单独歌曲插入文章代码： {% aplayer "See You Again" "Wiz Khalifa" "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3" "lrc:http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.lrc" %} 效果： [ti:速度与激情-see you again] [ar:Wiz Khalifa;Charlie Puth] [al:0] [by:漫天飞羽] [offset:-500] [00:01.65]速度与激情-see you again [00:04.65]演唱：Wiz Khalifa;Charlie Puth [00:07.65]歌词by：漫天飞羽 [00:09.65] [00:11.50]It's been a long day without you my friend [00:18.10]And I'll tell you all about it when I see you again [00:24.30]We've come a long way from where we began [00:29.23]Oh I'll tell you all about it when I see you again [00:36.30]When I see you again [00:40.60]Damn who knew all the planes we flew [00:43.54]Good things we've been through [00:45.35]That I'll be standing right here [00:47.56]Talking to you about another path [00:49.65]I know we loved to hit the road and laugh [00:52.14]But something told me that it wouldn't last [00:54.32]Had to switch up look at things [00:56.24]different see the bigger picture [00:58.75]Those were the days hard work forever pays [01:01.82]Now I see you in a better place (Now I see you in a better place) [01:03.82]ah~ [01:05.00]How could we not talk about family [01:08.60]when family's all that we got? [01:09.74]Everything I went through [01:10.47]you were standing there by my side [01:12.14]And now you gonna be with me for the last ride [01:14.21]It's been a long day without you my friend [01:21.55]And I'll tell you all about it when I see you again [01:27.45]We've come a long way from where we began [01:32.00]Oh I'll tell you all about it when I see you again [01:38.50]When I see you again [01:40.50] [01:56.41]First you both go out your way [01:58.11]And the vibe is feeling strong and what's [02:00.35]Small turn to a friendship a friendship [02:02.11]Turn into a bond and that bond will never [02:04.01]Be broke and the love will never get lost (Be broke and the love will never get lost) [02:09.10]And when brotherhood come first then the line [02:11.14]Will never be crossed established it on our own [02:13.87]When that line had to be drawn and that line is what [02:16.21]We reach so remember me when I'm gone [02:21.12]How could we not talk about family [02:22.01]when family's all that we got? [02:24.14]Everything I went through you [02:25.05]were standing there by my side [02:27.70]And now you gonna be with me for the last ride [02:29.21]Let the light guide your way hold every memory [02:38.24]As you go and every road you [02:43.87]take will always lead you home [02:50.12]Hoo~ [02:53.14]It's been a long day without you my friend [03:00.48]And I'll tell you all about it when I see you again [03:06.54]We've come a long way from where we began [03:12.21]Oh I'll tell you all about it when I see you again [03:17.45]When I see you again [03:20.10] [03:23.80]Again [03:25.50] [03:30.14]When I see you again see you again [03:35.14] [03:41.54]When I see you again [03:46.45] 找歌词，上歌词千寻 www.lrcgc.com。支持歌词找歌名，LRC歌词免费下载。 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "See You Again", author: "Wiz Khalifa", url: "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3", pic: "", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 歌单插入文章代码： 123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;（随机播放）, &apos;single&apos; (单曲播放), &apos;circulation&apos; (循环播放), &apos;order&apos; (列表播放)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 效果： var options = {"narrow":false,"autoplay":false,"showlrc":3,"mutex":true,"music":[{"title":"歌曲名","author":"歌手名","url":"https://什么什么什么.mp3","pic":"https://封面图.jpg","lrc":"https://歌词.lrc"},{"title":"歌曲名","author":"歌手名","url":"https://什么什么什么.mp3","pic":"https://封面图.jpg","lrc":"https://歌词.lrc"}]}; options.element = document.getElementById("aplayer1"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 音乐的外链本来想用网易云的外链，结果发现自己喜欢的歌都因为版权无法使用外链，所以我决定使用七牛云储存音乐以及歌词 视频插入文章代码： {% dplayer "url=http://olfa3o6q1.bkt.clouddn.com/%5B4K-60FPS%5D%20Avengers%20-%20Infinity%20War%20%7C%20Official%20Trailer%20%7C%202018.mp4" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %} 效果:(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://olfa3o6q1.bkt.clouddn.com/%5B4K-60FPS%5D%20Avengers%20-%20Infinity%20War%20%7C%20Official%20Trailer%20%7C%202018.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac中常用的操作]]></title>
    <url>%2F2017%2F11%2F27%2FMac%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[显示/隐藏 隐藏文件：Command+Shift+. 再按一次即可恢复。 在终端（Terminal）输入如下命令，即可显示隐藏文件和文件defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 如需再次隐藏原本隐藏的文件和文件夹，可以输入如下命令 defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder Finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 更换JAVA版本 （控制台复制代码，更改对应版本号回车即可）export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.x.x_xxx.jdk/Contents/Home 新建Hexo文章 进入到对应博客目录 cd blog 或 cd DanterM。 新建文章文件hexo n &quot;文章名称&quot;。 部署上传文章hexo g -d]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口被占用问题]]></title>
    <url>%2F2017%2F03%2F10%2F%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[用mac学习J2EE的时候调试项目经常会出现端口被占用问题，为了方便查找，专门做了这篇简单的BLOG方便查找。 首先运行Terminal查看端口被哪个程序占用sudo lsof -i tcp:port 如： sudo lsof -i tcp:8080 找到进程的PID，将占用进程杀死sudo kill -9 PID 如：sudo kill -9 23453]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS10.12.3安装WIN10]]></title>
    <url>%2F2017%2F02%2F20%2FMac%E5%AE%89%E8%A3%85WIN10%2F</url>
    <content type="text"><![CDATA[相信很多Mac用户都会因为或多或少的原因需要安装Windows系统，但是网络上能找到的相关文章太过陈旧，只好自己摸索。这篇文章就讲解了macOS10.12.3系统安装WIN10双系统的过程以及可能碰到的问题。 第一步下载适当win10镜像，镜像在Google或者Baidu上很容易找到，下载下来即可。 第二步在下载镜像的过程中，检查安装所需，确保之后的步骤可以顺利进行。 附：Apple官网的Boot Camp助理帮助附：Apple官方文档 上面两个网页可以解决大部分的问题，但事实不是如此，我每次尝试新事物时都会被或多或少的困难折磨—-macOS sierra系统更新后多出来了许多不知道的功能，直接导致我碰上这次双系统之旅的第一只拦路虎。我的当前系统是macOS10.12.3，苹果在优化存储空间上下了很大功夫，多出来了一个“优化存储空间”的功能，导致了我的mac的存储空间中有40多G的可清除部分，以致于没有足够的空间用来安装Win10，最终通过Google解决。 解决方法如下：设置–iCloud–iCloud Drive（选项）–去掉优化Mac存储空间–重新启动（如果不行多试几次） 第三步镜像下载完成，环境所需没有问题，便可以开始第三步了。1、打开Boot Camp助理（Launchpad–其他–Boot Camp助理）2、点击继续–选择镜像–分配空间大小–继续–系统会自动下载所需文件（保持网速稳定）这时我又碰到了一个问题–您的磁盘未能分区解决方法：（当时没办法截图）重启电脑–开机时按住command+R–进入磁盘管理–如果发现Macintosh HD是灰色的话，选中后点装载后选择急救。修复后重新启动问题便解决了。 第四步之后就是简单熟悉的Windows系统安装了，一步一步来，序列号可以先跳过。进入WIN10系统–打开我的电脑进入除了系统盘的另一个盘–打开BootCamp文件夹–运行setup–结束重启–完成驱动安装。 注意安装软件以及破解系统时不要被病毒劫持主页了，很恶心很麻烦。]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Sublime Text3的汉化]]></title>
    <url>%2F2017%2F02%2F19%2FMac%E4%B8%ADSublime-Text3%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.下载汉化文件Default.sublime-package 2.打开 Sublime Text3选择Sublime Text–Preferences–Browse Packages点开后会自动打开Finder 如下图 3.找到Installed Packages点击图中上方的Installed Packages 如下图 4.复制文件到Installed Packages中将下载的Default.sublime-package放在Installed Packages文件夹中 3.完成汉化]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred中Workflow的简单案例--新建文件]]></title>
    <url>%2F2017%2F02%2F15%2FAlfred%E4%B8%ADWorkflow%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B--%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[从头构建一个“新建文件”功能的workflow文件自从使用了macbook之后，我便在网络上大量搜索能够有效提高效率的软件，大部分人的推荐都会有一个叫做Alfred的应用,这篇文章讲解了一个简单的alfredworkflow是如何写出来的。 什么是Alfred?Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac. 点击进入Alfred官网Workflow汇总 直切主题，有自己写workflow想法的你肯定已经知道什么是Alfred、怎么使用Alfred，但实际上自己写一个workflow真的很简单。下面我会一步一步的整理出我是如何写出这一简单的功能的。 1.设置Workflow Defaults1.1打开Alfred打开Alfred的Workflow，点击左下角的加号。 1.2填写基本信息 2.创建Blank Workflow2.1新建Blank Workflow 2.2填写信息分别为workflow名称、功能描述、功能分类，图中右上角的方框是workflow的Icon，支持拖拽找到图片直接拖进去即可。 2.3得到workflow界面 3.制作Workflow3.1 新建Inputs在界面上右键得到如下图结果，选择Inputs中的Keyword 3.1.1 填写自定义信息得到如下图结果，填写你想要设置的 激活词组 、标题以及简介，我这里定义成new。 3.1.2实际使用演示 3.2 新建Actions在界面上右键得到如下图结果，选择Actions中的Run NSAppleScript 3.2.1 编辑代码双击得到如下图结果，接着双击转到代码编辑页面将your script here更换成你想要实现的功能的代码即可,当然此处只能用Apple的script来写。 此处我的代码是 on alfred_script(q) tell application &quot;Finder&quot; set selection to make new file at (get insertion location) end tell end alfred_script 如果想用其他语言在请选择在3.2时选择Run Script即可，可以自己选择所用语言，如下图 3.2.2连接模块 4.结果 5.附导出文件new-file.alfredworkflow]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法简介]]></title>
    <url>%2F2017%2F02%2F15%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[主要内容以下内容来源于younghz的Github Markdown是什么？谁发明了这么个东西？为什么要使用它？怎么使用？都谁在用？感觉有意思？不怕你看见，就怕你试试 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. _谁_发明了这么个东西？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案居然被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途（又是一位犹太人）。 3. 为什么要使用它？ 它是易读（看起开舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰的组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. _怎么_使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 废话太多，下面正文，Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); } 注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，_斜体_粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 都_谁_在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 感觉有意思？趁热打铁，推荐几个_工具_。 Chrome下的stackedit插件可以离线使用，很爽。也不用担心平台受限。在线的dillinger.io算是评价好的了，可是不能离线使用。 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。推荐。 Linux下的ReText不错。 其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。我现在使用马克飞象 + Markdown-here，先编辑好，然后一键格式化，挺方便。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。 以上基本是所有traditonal markdown的语法。 补充：随着macOS 10.12的更新，Mou已经无法在新系统上使用，推荐的Markdown编辑器有MWeb、Ulysses、Byword等。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>优秀文章</tag>
      </tags>
  </entry>
</search>
