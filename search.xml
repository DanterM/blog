<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习中的四种评价函数]]></title>
    <url>%2F2018%2F04%2F26%2F%E8%AF%84%E4%BB%B7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[评价函数（EvaluationFunction） 在毕业设计过程中常使用的五种基于预测误差的评价指标： 均方根误差（RMSE） R-平方（R2） 平均绝对百分误差（MAPE） 平均绝对误差（MAE） 希尔不等系数（TIC）（暂不使用） 均方根误差（RMSE）RMSE是预测值与真实值的误差平方根的均值。均方根误差RMSE(root-mean-square error)， 均方根误差亦称标准误差,它是观测值与真值偏差的平方与观测次数比值的平方根。均方根误差是用来衡量观测值同真值之间的偏差。标准误差对一组测量中的特大或特小误差反映非常敏感，所以，标准误差能够很好地反映出测量的精密度。可用标准误差作为评定这一测量过程精度的标准。计算公式如下： 优点：标准化平均方差对均方差进行了标准化改进，通过计算拟评估模型与以均值为基础的模型之间准确性的比率，标准化平均方差取值范围通常为0～1，比率越小，说明模型越优于以均值进行预测的策略，NMSE的值大于1，意味着模型预测还不如简单地把所有观测值的平均值作为预测值， 缺点：但是通过这个指标很难估计预测值和观测值的差距，因为它的单位也和原变量不一样了，综合各个指标的优缺点，我们使用三个指标对模型进行评估。 R-平方（R^2）R^2方法是将预测值跟只使用均值的情况下相比，看能好多少。其区间通常在（0,1）之间。0表示还不如什么都不预测，直接取均值的情况，而1表示所有预测跟真实结果完美匹配的情况。计算公式如下： 平均绝对误差（MAE）、平均绝对百分误差（MAPE）相对百分误差绝对值的平均值MAPE(mean absolute percentage error):可以用来衡量一个模型预测结果的好坏。MAE平均绝对误差=︱原值-估计值︱/n 计算公式如下： MAE优缺点：虽然平均绝对误差能够获得一个评价值，但是你并不知道这个值代表模型拟合是优还是劣，只有通过对比才能达到效果； 论文片段节选3.3回归模型的性能为了选出其中最好的模型，所有的回归模型都经过了10次交叉验证的训练。为了加快计算的速度，采用了并行计算的doParallel包[59]。第一个训练的模型是多元线性回归。多元线性回归使用所有可用的预测因子，并找到合适的斜率来量化每个预测因子和响应的影响[55]。为了比较每个回归模型的性能，这里使用了不同的性能评价指标:根平均平方误差(RMSE)、确定系数或r平方/R^2、平均绝对误差(MAE)和平均绝对百分比误差(MAPE)。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F04%2F21%2FGit%2F</url>
    <content type="text"><![CDATA[版权归廖雪峰的官方网站所有 一、创建版本库 1、创建空目录1234$ mkdir learngit$ cd learngit$ pwd/Users/Jarvis/learngit pwd命令用于显示当前目录，在Mac上，仓库位于/Users/Jarvis/learngit 2、git init12$ git initInitialized empty Git repository in /Users/Jarvis/learngit/.git/ 之后当前目录下多了一个 .git 的目录，这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。 3、添加文件到版本库自己新建一个文件放到 learngit 目录下。一定要放到 learngit 目录下（子目录也行），因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令 git add 告诉 Git ，把文件添加到仓库： 1$ git add readme.txt 执行上面的命令，没有任何显示，这就对了， Unix 的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令 git commit 告诉 Git ，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下 git commit 命令， -m 后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入 -m &quot;xxx&quot; 行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行 Google ，我不告诉你这个参数。 git commit 命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么 Git 添加文件需要 add ， commit 一共两步呢？因为 commit 可以一次提交很多文件，所以你可以多次 add 不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 二、时光机穿梭 我们已经添加了文件，现在我们已经对文件进行了修改。 修改后，我们运行 git status 命令看看结果： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status 命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们， readme.txt 被修改过了，但还没有准备提交的修改。 虽然 Git 告诉我们 readme.txt 被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你周末休息回来，周一上班时，已经记不清上次怎么修改的 readme.txt ，所以，需要用 git diff 这个命令看看： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 1$ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： 1234567$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： 123$ git commit -m &quot;add distributed&quot;[master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： 123$ git status# On branch masternothing to commit (working directory clean) Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 1、版本回退在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在 Git 中，我们用 git log 命令查看 git log命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 –pretty=oneline 参数： 1$ git log --pretty=oneline 需要友情提示的是，你看到的一大串类似3628164…882e1e0的是 commit id （版本号），和 SVN 不一样， Git 的 commit id 不是1，2，3……递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，而且你看到的 commit id 和我的肯定不一样，以你自己的为准。为什么 commit id 需要用这么一大串数字表示呢？因为 Git 是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，应该怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本 “append GPL” 回退到上一个版本 “add distributed” ，就可以使用 git reset 命令： 12$ git reset --hard HEAD^HEAD is now at ea34578 add distributed –hard 参数有啥意义？这个后面再讲，现在你先放心使用。 看看 readme.txt 的内容是不是版本 add distributed ： 123$ cat readme.txtGit is a distributed version control system.Git is free software. 还可以继续回退到上一个版本 wrote a readme file 。 但是这时，最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个 append GPL 的 commit id 是3628164…，于是就可以指定回到未来的某个版本： 1$ git reset --hard 3628164 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：改为指向 add distributed ： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。 现在总结一下： HEAD指向的版本就是当前版本，因此， Git 允许我们在版本的历史之间穿梭，使用命令 git reset –hard commit_id 。 穿梭前，用 git log 可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用 git reflog 查看命令历史，以便确定要回到未来的哪个版本。 2、工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容。 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态,Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下。 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的，现在版本库变成了这样，暂存区就没有任何内容了。 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 3、管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容；然后git add readme.txt，再修改readme.txt，之后git commit提交，我们会发现只有第一次修改的内容。 别激动，我们回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 4、撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改： $ git checkout – readme.txt命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： 1234567$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 12345678910111213141516$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)还记得如何丢弃工作区的修改吗？$ git checkout -- readme.txt$ git status# On branch masternothing to commit (working directory clean) 整个世界终于清静了！ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了。 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 5、删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： 12345$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master 94cdc44] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 1$ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## deleted: test.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 123456$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 三、远程仓库到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key。 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 1、添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1$ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 123456789$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (19/19), 13.73 KiB, done.Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 2、从远程库克隆现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills，我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件。 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： 123456789$ git clone git@github.com:xxxxxx/gitskills.gitCloning into &apos;gitskills&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Receiving objects: 100% (3/3), done.$ cd gitskills$ lsREADME.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/xxxxxx/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 小结要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 四、分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 1、创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： 12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 然后，用git branch命令查看当前分支： 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： 1Creating a new branch is quick. 然后提交： 1234$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev fec145a] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： 12$ git checkout masterSwitched to branch &apos;master&apos; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： 12345$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 12$ git branch -d devDeleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了： 12$ git branch* master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 小结Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 2、解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git checkout -b feature1Switched to a new branch &apos;feature1&apos; 修改readme.txt最后一行，改为： 1Creating a new branch is quick AND simple. 在feature1分支上提交： 1234$ git add readme.txt $ git commit -m &quot;AND simple&quot;[feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： 123$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 1 commit. Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： 1Creating a new branch is quick &amp; simple. 提交： 1234$ git add readme.txt $ git commit -m &quot;&amp; simple&quot;[master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 12345678910$ git status# On branch master# Your branch is ahead of &apos;origin/master&apos; by 2 commits.## Unmerged paths:# (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)## both modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 1Creating a new branch is quick and simple. 再提交： 123$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master 59bc1cb] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was 75a857c). 工作完成。 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 3、分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： 12$ git checkout -b devSwitched to a new branch &apos;dev&apos; 修改readme.txt文件，并提交一个新的commit： 1234$ git add readme.txt $ git commit -m &quot;add merge&quot;[dev 6224937] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： 12$ git checkout masterSwitched to branch &apos;master&apos; 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： 1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 1234567$ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\| * 6224937 add merge|/* 59bc1cb conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样： 分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 4、Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 12345678910111213$ git status# On branch dev# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt# 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 12345$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits.$ git checkout -b issue-101Switched to a new branch &apos;issue-101&apos; 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： 1234$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： 123456789$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits.$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &apos;recursive&apos; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ 12345$ git checkout devSwitched to branch &apos;dev&apos;$ git status# On branch devnothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1234567891011121314$ git stash pop# On branch dev# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了： 1$ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 5、Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： 12$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos; 5分钟后，开发完毕： 123456789101112$ git add vulcan.py$ git status# On branch feature-vulcan# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## new file: vulcan.py#$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 756d4af] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： 1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是， 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个分支还是必须就地销毁： 123$ git branch -d feature-vulcanerror: The branch &apos;feature-vulcan&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。 现在我们强行删除： 12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 756d4af). 终于删除成功！ 小结开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 6、多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 或者，用git remote -v显示更详细的信息： 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &apos;learngit&apos;...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 1234567891011$ git commit -m &quot;add /usr/bin/env&quot;[dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 123456789101112$ git add hello.py $ git commit -m &quot;add coding: utf-8&quot;[dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)hint: before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 12345678910111213141516$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/&lt;branch&gt; git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 12$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin. 再pull： 1234$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 12345678910$ git commit -m &quot;merge &amp; fix hello.py&quot;[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git 291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 五、标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 Git有commit，为什么还要引入tag？ “请把上周一的那个版本打包发布，commit号是6a5819e…” “一串乱七八糟的数字不好找！” 如果换一个办法： “请把上周一的那个版本打包发布，版本号是v1.2” “好的，按照tag v1.2查找commit就行！” 所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 1、创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： 1234567891011$ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令： 1$ git tag v0.9 6224937 再用命令git tag查看标签： 123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 1234567$ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 11:22:08 2013 +0800 add merge... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 用命令git show &lt;tagname&gt;可以看到说明文字： 123456789101112$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 26 07:28:11 2013 +0800version 0.1 releasedcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPL 还可以通过-s用私钥签名一个标签： 1$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错： 123gpg: signing failed: secret key not availableerror: gpg failed to sign the dataerror: unable to sign the tag 如果报错，请参考GnuPG帮助文档配置Key。 用命令git show &lt;tagname&gt;可以看到PGP签名信息： 1234567891011121314151617$ git show v0.2tag v0.2Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 26 07:28:33 2013 +0800signed version 0.2 released-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.12 (Darwin)iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...-----END PGP SIGNATURE-----commit fec145accd63cdc9ed95a2f557ea0658a2a6537fAuthor: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 10:37:30 2013 +0800 branch test 用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。 小结 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 2、操作标签如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was e078af9) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 554 bytes, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new tag] v0.2 -&gt; v0.2 * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To git@github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3入门]]></title>
    <url>%2F2018%2F04%2F17%2FCSS3%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[CSS3 被划分为模块。 其中最重要的 CSS3 模块包括： 选择器 框模型 背景和边框 文本效果 2D/3D 转换 动画 多列布局 用户界面 CSS3 边框 通过 CSS3，您能够创建圆角边框，向矩形添加阴影，使用图片来绘制边框 - 并且不需使用设计软件，比如 PhotoShop。 在本章中，您将学到以下边框属性： border-radius box-shadow border-image Internet Explorer 9+ 支持 border-radius 和 box-shadow 属性。 Firefox、Chrome 以及 Safari 支持所有新的边框属性。 注释：对于 border-image，Safari 5 以及更老的版本需要前缀 -webkit-。 Opera 支持 border-radius 和 box-shadow 属性，但是对于 border-image 需要前缀 -o-。 CSS3 圆角边框 在 CSS2 中添加圆角矩形需要技巧。我们必须为每个圆角使用不同的图片。 在 CSS3 中，创建圆角是非常容易的。 在 CSS3 中，border-radius 属性用于创建圆角： 实例向 div 元素添加圆角： 123456div&#123;border:2px solid;border-radius:25px;-moz-border-radius:25px; /* Old Firefox */&#125; CSS3 边框阴影在 CSS3 中，box-shadow 用于向方框添加阴影：实例向 div 元素添加方框阴影： 1234div&#123;box-shadow: 10px 10px 5px #888888;&#125; CSS3 边框图片通过 CSS3 的 border-image 属性，您可以使用图片来创建边框. 实例使用图片创建围绕 div 元素的边框： 1234567div&#123;border-image:url(border.png) 30 30 round;-moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */-webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */-o-border-image:url(border.png) 30 30 round; /* Opera */&#125; CSS3 背景 CSS3 包含多个新的背景属性，它们提供了对背景更强大的控制。 在本章，您将学到以下背景属性： background-size background-origin Internet Explorer 9+、Firefox、Chrome、Safari 以及 Opera 支持新的背景属性。 CSS3 background-size 属性background-size 属性规定背景图片的尺寸。 在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。 您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 例子 1调整背景图片的大小： 1234567div&#123;background:url(bg_flower.gif);-moz-background-size:63px 100px; /* 老版本的 Firefox */background-size:63px 100px;background-repeat:no-repeat;&#125; 例子 2对背景图片进行拉伸，使其完成填充内容区域： 1234567div&#123;background:url(bg_flower.gif);-moz-background-size:40% 100%; /* 老版本的 Firefox */background-size:40% 100%;background-repeat:no-repeat;&#125; CSS3 background-origin 属性background-origin 属性规定背景图片的定位区域。 背景图片可以放置于 content-box、padding-box 或 border-box 区域。 实例在 content-box 中定位背景图片： 12345678div&#123;background:url(bg_flower.gif);background-repeat:no-repeat;background-size:100% 100%;-webkit-background-origin:content-box; /* Safari */background-origin:content-box;&#125; CSS3 多重背景图片CSS3 允许您为元素使用多个背景图像。 实例为 body 元素设置两幅背景图片： 1234body&#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif);&#125; CSS3 文本效果 CSS3 包含多个新的文本特性。 在本章中，您将学到如下文本属性： text-shadow word-wrap Internet Explorer 10、Firefox、Chrome、Safari 以及 Opera 支持 text-shadow 属性。 所有主流浏览器都支持 word-wrap 属性。 注释：Internet Explorer 9 以及更早的版本，不支持 text-shadow 属性。 CSS3 文本阴影在 CSS3 中，text-shadow 可向文本应用阴影。 您能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色： 实例向标题添加阴影： 1234h1&#123;text-shadow: 5px 5px 5px #FF0000;&#125; CSS3 自动换行单词太长的话就可能无法超出某个区域 在 CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行 - 即使这意味着会对单词进行拆分 下面是 CSS 代码： 实例允许对长单词进行拆分，并换行到下一行： 1p &#123;word-wrap:break-word;&#125; CSS3 字体 CSS3 @font-face 规则在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。 通过 CSS3，web 设计师可以使用他们喜欢的任意字体。 当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。 您“自己的”的字体是在 CSS3 @font-face 规则中定义的。 Firefox、Chrome、Safari 以及 Opera 支持 .ttf (True Type Fonts) 和 .otf (OpenType Fonts) 类型的字体。Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。注释：Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。 使用您需要的字体在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。 如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)： 实例 12345678910111213&lt;style&gt; @font-face&#123;font-family: myFirstFont;src: url(&apos;Sansation_Light.ttf&apos;), url(&apos;Sansation_Light.eot&apos;); /* IE9+ */&#125;div&#123;font-family:myFirstFont;&#125;&lt;/style&gt; 使用粗体字体您必须为粗体文本添加另一个包含描述符的 @font-face： 实例 1234567@font-face&#123;font-family: myFirstFont;src: url(&apos;Sansation_Bold.ttf&apos;), url(&apos;Sansation_Bold.eot&apos;); /* IE9+ */font-weight:bold;&#125; 文件 “Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。通过这种方式，我们可以为相同的字体设置许多 @font-face 规则。 下面的表格列出了能够在 @font-face 规则中定义的所有字体描述符： CSS3 2D 转换 CSS3 转换通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 转换是使元素改变形状、尺寸和位置的一种效果。 您可以使用 2D 或 3D 转换来转换您的元素。 Internet Explorer 10、Firefox 以及 Opera 支持 transform 属性。Chrome 和 Safari 需要前缀 -webkit-。注释：Internet Explorer 9 需要前缀 -ms-。 2D 转换在本章中，您将学到如下 2D 转换方法： translate() rotate() scale() skew() matrix() 实例 12345678div&#123;transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */-o-transform: rotate(30deg); /* Opera */-moz-transform: rotate(30deg); /* Firefox */&#125; translate() 方法通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 实例 12345678div&#123;transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */-o-transform: translate(50px,100px); /* Opera */-moz-transform: translate(50px,100px); /* Firefox */&#125; 值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。 rotate() 方法通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 实例 12345678div&#123;transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */-o-transform: rotate(30deg); /* Opera */-moz-transform: rotate(30deg); /* Firefox */&#125; 值 rotate(30deg) 把元素顺时针旋转 30 度。 scale() 方法通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： 实例 12345678div&#123;transform: scale(2,4);-ms-transform: scale(2,4); /* IE 9 */-webkit-transform: scale(2,4); /* Safari 和 Chrome */-o-transform: scale(2,4); /* Opera */-moz-transform: scale(2,4); /* Firefox */&#125; 值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 skew() 方法通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数： 实例 12345678div&#123;transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */-o-transform: skew(30deg,20deg); /* Opera */-moz-transform: skew(30deg,20deg); /* Firefox */&#125; 值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 matrix() 方法matrix() 方法把所有 2D 转换方法组合在一起。 matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 实例如何使用 matrix 方法将 div 元素旋转 30 度： 12345678div&#123;transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */-o-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Opera */&#125; CSS3 3D 转换 3D 转换CSS3 允许您使用 3D 转换来对元素进行格式化。 在本章中，您将学到其中的一些 3D 转换方法： rotateX() rotateY() Internet Explorer 10 和 Firefox 支持 3D 转换。Chrome 和 Safari 需要前缀 -webkit-。Opera 仍然不支持 3D 转换（它只支持 2D 转换）。 rotateX() 方法通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转。 实例 123456div&#123;transform: rotateX(120deg);-webkit-transform: rotateX(120deg); /* Safari 和 Chrome */-moz-transform: rotateX(120deg); /* Firefox */&#125; rotateY() 旋转通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转。 实例 123456div&#123;transform: rotateY(130deg);-webkit-transform: rotateY(130deg); /* Safari 和 Chrome */-moz-transform: rotateY(130deg); /* Firefox */&#125; CSS3 过渡 CSS3 过渡通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 Internet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。Safari 需要前缀 -webkit-。注释：Internet Explorer 9 以及更早的版本，不支持 transition 属性。注释：Chrome 25 以及更早的版本，需要前缀 -webkit-。 它如何工作？CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。 要实现这一点，必须规定两项内容： 规定您希望把效果添加到哪个 CSS 属性上 规定效果的时长 实例应用于宽度属性的过渡效果，时长为 2 秒： 1234567div&#123;transition: width 2s;-moz-transition: width 2s; /* Firefox 4 */-webkit-transition: width 2s; /* Safari 和 Chrome */-o-transition: width 2s; /* Opera */&#125; 注释：如果时长未规定，则不会有过渡效果，因为默认值是 0。 效果开始于指定的 CSS 属性改变值时。CSS 属性改变的典型时间是鼠标指针位于元素上时： 实例规定当鼠标指针悬浮于 元素上时： 1234div:hover&#123;width:300px;&#125; 注释：当指针移出元素时，它会逐渐变回原来的样式。 多项改变如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开： 实例向宽度、高度和转换添加过渡效果： 1234567div&#123;transition: width 2s, height 2s, transform 2s;-moz-transition: width 2s, height 2s, -moz-transform 2s;-webkit-transition: width 2s, height 2s, -webkit-transform 2s;-o-transition: width 2s, height 2s,-o-transform 2s;&#125; 过渡属性下面的表格列出了所有的转换属性： 下面的两个例子设置所有过渡属性： 实例在一个例子中使用所有过渡属性： 12345678910111213141516171819202122div&#123;transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s;/* Firefox 4 */-moz-transition-property:width;-moz-transition-duration:1s;-moz-transition-timing-function:linear;-moz-transition-delay:2s;/* Safari 和 Chrome */-webkit-transition-property:width;-webkit-transition-duration:1s;-webkit-transition-timing-function:linear;-webkit-transition-delay:2s;/* Opera */-o-transition-property:width;-o-transition-duration:1s;-o-transition-timing-function:linear;-o-transition-delay:2s;&#125; 实例与上面的例子相同的过渡效果，但是使用了简写的 transition 属性： 12345678910div&#123;transition: width 1s linear 2s;/* Firefox 4 */-moz-transition:width 1s linear 2s;/* Safari and Chrome */-webkit-transition:width 1s linear 2s;/* Opera */-o-transition:width 1s linear 2s;&#125; CSS3 动画 通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 CSS3 @keyframes 规则如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。 @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。Chrome 和 Safari 需要前缀 -webkit-。注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 实例 1234567891011121314151617181920212223@keyframes myfirst&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;from &#123;background: red;&#125;to &#123;background: yellow;&#125;&#125; CSS3 动画当您在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 实例把 “myfirst” 动画捆绑到 div 元素，时长：5 秒： 1234567div&#123;animation: myfirst 5s;-moz-animation: myfirst 5s; /* Firefox */-webkit-animation: myfirst 5s; /* Safari 和 Chrome */-o-animation: myfirst 5s; /* Opera */&#125; 注释：您必须定义动画的名称和时长。如果忽略时长，则动画不会允许，因为默认值是 0。 什么是 CSS3 中的动画？动画是使元素从一种样式逐渐变化为另一种样式的效果。 您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 实例当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变： 12345678910111213141516171819202122232425262728293031@keyframes myfirst&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125; 实例改变背景色和位置： 1234567891011121314151617181920212223242526272829303132333435@keyframes myfirst&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125; CSS3 动画属性下面的表格列出了 @keyframes 规则和所有动画属性： 下面的两个例子设置了所有动画属性： 实例运行名为 myfirst 的动画，其中设置了所有动画属性： 12345678910111213141516171819202122232425262728293031323334div&#123;animation-name: myfirst;animation-duration: 5s;animation-timing-function: linear;animation-delay: 2s;animation-iteration-count: infinite;animation-direction: alternate;animation-play-state: running;/* Firefox: */-moz-animation-name: myfirst;-moz-animation-duration: 5s;-moz-animation-timing-function: linear;-moz-animation-delay: 2s;-moz-animation-iteration-count: infinite;-moz-animation-direction: alternate;-moz-animation-play-state: running;/* Safari 和 Chrome: */-webkit-animation-name: myfirst;-webkit-animation-duration: 5s;-webkit-animation-timing-function: linear;-webkit-animation-delay: 2s;-webkit-animation-iteration-count: infinite;-webkit-animation-direction: alternate;-webkit-animation-play-state: running;/* Opera: */-o-animation-name: myfirst;-o-animation-duration: 5s;-o-animation-timing-function: linear;-o-animation-delay: 2s;-o-animation-iteration-count: infinite;-o-animation-direction: alternate;-o-animation-play-state: running;&#125; 实例与上面的动画相同，但是使用了简写的动画 animation 属性： 12345678910div&#123;animation: myfirst 5s linear 2s infinite alternate;/* Firefox: */-moz-animation: myfirst 5s linear 2s infinite alternate;/* Safari 和 Chrome: */-webkit-animation: myfirst 5s linear 2s infinite alternate;/* Opera: */-o-animation: myfirst 5s linear 2s infinite alternate;&#125; CSS3 多列 通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！ 在本章中，您将学习如下多列属性： column-count column-gap column-rule Internet Explorer 10 和 Opera 支持多列属性。Firefox 需要前缀 -moz-。Chrome 和 Safari 需要前缀 -webkit-。注释： Internet Explorer 9 以及更早的版本不支持多列属性。 CSS3 创建多列column-count 属性规定元素应该被分隔的列数： 实例把 div 元素中的文本分隔为三列： 123456div&#123;-moz-column-count:3; /* Firefox */-webkit-column-count:3; /* Safari 和 Chrome */column-count:3;&#125; CSS3 规定列之间的间隔column-gap 属性规定列之间的间隔： 实例规定列之间 40 像素的间隔： 123456div&#123;-moz-column-gap:40px; /* Firefox */-webkit-column-gap:40px; /* Safari 和 Chrome */column-gap:40px;&#125; CSS3 列规则column-rule 属性设置列之间的宽度、样式和颜色规则。 实例规定列之间的宽度、样式和颜色规则： 123456div&#123;-moz-column-rule:3px outset #ff0000; /* Firefox */-webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */column-rule:3px outset #ff0000;&#125; CSS3 用户界面在 CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。 在本章中，您将学到以下用户界面属性： resize box-sizing outline-offset Firefox、Chrome 以及 Safari 支持 resize 属性。Internet Explorer、Chrome、Safari 以及 Opera 支持 box-sizing 属性。Firefox 需要前缀 -moz-。所有主流浏览器都支持 outline-offset 属性，除了 Internet Explorer。 CSS3 Resizing在 CSS3，resize 属性规定是否可由用户调整元素尺寸。 CSS 代码如下： 实例规定 div 元素可由用户调整大小： 12345div&#123;resize:both;overflow:auto;&#125; CSS3 Box Sizingbox-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。 实例规定两个并排的带边框方框： 12345678div&#123;box-sizing:border-box;-moz-box-sizing:border-box; /* Firefox */-webkit-box-sizing:border-box; /* Safari */width:50%;float:left;&#125; CSS3 Outline Offsetoutline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 轮廓与边框有两点不同： 轮廓不占用空间 轮廓可能是非矩形 CSS 代码如下： 实例规定边框边缘之外 15 像素处的轮廓： 123456div&#123;border:2px solid black;outline:2px solid red;outline-offset:15px;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON入门]]></title>
    <url>%2F2018%2F04%2F15%2FJSON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JSON：JavaScript 对象表示法（JavaScript Object Notation）。 JSON 是存储和交换文本信息的语法。类似 XML。 JSON 比 XML 更小、更快，更易解析。 12345678&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125;]&#125;这个 employee 对象是包含 3 个员工记录（对象）的数组。 什么是 JSON ？ JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言(JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。) JSON 具有自我描述性，更易理解 JSON - 转换为 JavaScript 对象JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。 由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval( ) 函数，用 JSON 数据来生成原生的 JavaScript 对象。 类似 XML JSON 是纯文本 JSON 具有“自我描述性”（人类可读） JSON 具有层级结构（值中存在值） JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输 相比 XML 的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 为什么使用 JSON？对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 用 eval() 处理 JSON 字符串 JSON 语法是 JavaScript 语法的子集。 JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 名称/值对 JSON 数据的书写格式是：名称/值对。 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： 1&quot;firstName&quot; : &quot;John&quot; 这很容易理解，等价于这条 JavaScript 语句： 1firstName = &quot;John&quot; JSON 值JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON 对象 JSON 对象在花括号中书写： 对象可以包含多个名称/值对： 1&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125; 这一点也容易理解，与这条 JavaScript 语句等价： 12firstName = &quot;John&quot;lastName = &quot;Doe&quot; JSON 数组 JSON 数组在方括号中书写： 数组可包含多个对象： 1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。 JSON 使用 JavaScript 语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。 通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值： 例子 12345var employees = [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项： 1employees[0].lastName; 返回的内容是： 1Gates 可以像这样修改数据： 1employees[0].lastName = &quot;Jobs&quot;; JSON 文件JSON 文件的文件类型是 “.json”JSON 文本的 MIME 类型是 “application/json” 把 JSON 文本转换为 JavaScript 对象 JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。 为了更简单地为您讲解，我们使用字符串作为输入进行演示（而不是文件）。 JSON 实例 - 来自字符串的对象 创建包含 JSON 语法的 JavaScript 字符串： 1234var txt = &apos;&#123; &quot;employees&quot; : [&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125; ]&#125;&apos;; 由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。 eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误： 1var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); 在网页中使用 JavaScript 对象： 例子 123456789&lt;p&gt;First Name: &lt;span id=&quot;fname&quot;&gt;&lt;/span&gt;&lt;br /&gt;Last Name: &lt;span id=&quot;lname&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&quot;fname&quot;).innerHTML = obj.employees[1].firstNamedocument.getElementById(&quot;lname&quot;).innerHTML = obj.employees[1].lastName&lt;/script&gt; JSON 解析器 提示：eval() 函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。 使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本，而不会编译脚本。 在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。 较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5知识点汇总]]></title>
    <url>%2F2018%2F04%2F15%2FHTML5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[注：本博客版权为W3Cschool所有。这篇博客的诞生的原因是学习的时候习惯性的写成了博客。 HTML5教程 HTML5 是 W3C 与 WHATWG 合作的结果。 W3C 指 World Wide Web Consortium，万维网联盟。 WHATWG 指 Web Hypertext Application Technology Working Group。 WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。 为 HTML5 建立的一些规则： 新特性应该基于 HTML、CSS、DOM 以及 JavaScript。 减少对外部插件的需求（比如 Flash） 更优秀的错误处理 更多取代脚本的标记 HTML5 应该独立于设备 开发进程应对公众透明 新特性 HTML5 中的一些有趣的新特性： 用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 对本地离线存储的更好的支持 新的特殊内容元素，比如 article、footer、header、nav、section 新的表单控件，比如 calendar、date、time、email、url、search 一、HTML5 视频当前，video 元素支持三种视频格式： 格式 IE Firefox Opera Chrome Safari Ogg NO 3.5+ 10.5+ 5.0+ NO MPEG4 9.0+ NO NO 5.0+ 3.0+ WebM NO 4.0+ 10.6+ 6.0+ NO Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件 MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件 WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件 视频工作 controls 属性供添加播放、暂停和音量控件。 包含宽度和高度属性也是不错的主意。 12345&lt;video&gt; 与 &lt;/video&gt; 之间插入的内容是供不支持 video 元素的浏览器显示的：&lt;video src=&quot;movie.ogg&quot; width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 上面的例子使用一个 Ogg 文件，适用于Firefox、Opera 以及 Chrome 浏览器。 要确保适用于 Safari 浏览器，视频文件必须是 MPEG4 类型。 video 元素允许多个 source 元素。source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式： 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 注：Internet Explorer 8 不支持 video 元素。在 IE 9 中，将提供对使用 MPEG4 的 video 元素的支持。 HTML &lt;video&gt; 标签 HTML5 &lt;video&gt; - 使用 DOM 进行控制 HTML5 &lt;video&gt; 元素同样拥有方法、属性和事件。 其中的方法用于播放、暂停以及加载等。其中的属性（比如时长、音量等）可以被读取或设置。其中的 DOM 事件能够通知您，比方说，&lt;video&gt; 元素开始播放、已暂停，已停止，等等。 HTML5 &lt;video&gt; - 方法、属性以及事件 注释：在所有属性中，只有 videoWidth 和 videoHeight 属性是立即可用的。在视频的元数据已加载后，其他属性才可用。 二、HTML5 音频Web 上的音频直到现在，仍然不存在一项旨在网页上播放音频的标准。 今天，大多数音频是通过插件（比如 Flash）来播放的。然而，并非所有浏览器都拥有同样的插件。 HTML5 规定了一种通过 audio 元素来包含音频的标准方法。 audio 元素能够播放声音文件或者音频流。 音频格式当前，audio 元素支持三种音频格式： 如何工作 如需在 HTML5 中播放音频，您所有需要的是： 12&lt;audio src=&quot;song.ogg&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; control 属性供添加播放、暂停和音量控件。 与 之间插入的内容是供不支持 audio 元素的浏览器显示的：实例 123&lt;audio src=&quot;song.ogg&quot; controls=&quot;controls&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; 上面的例子使用一个 Ogg 文件，适用于Firefox、Opera 以及 Chrome 浏览器。 要确保适用于 Safari 浏览器，音频文件必须是 MP3 或 Wav 类型。 audio 元素允许多个 source 元素。source 元素可以链接不同的音频文件。浏览器将使用第一个可识别的格式： 实例 12345&lt;audio controls=&quot;controls&quot;&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; Internet ExplorerInternet Explorer 8 不支持 audio 元素。在 IE 9 中，将提供对 audio 元素的支持。 &lt;audio&gt; 标签的属性 三、HTML 5 拖放拖放（Drag 和 drop）是 HTML5 标准的组成部分。 拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置。 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 浏览器支持Internet Explorer 9、Firefox、Opera 12、Chrome 以及 Safari 5 支持拖放。 注释：在 Safari 5.1.2 中不支持拖放。 HTML5 拖放实例下面的例子是一个简单的拖放实例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function allowDrop(ev)&#123;ev.preventDefault();&#125;function drag(ev)&#123;ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125;function drop(ev)&#123;ev.preventDefault();var data=ev.dataTransfer.getData(&quot;Text&quot;);ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot;ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot;ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 它看上去也许有些复杂，不过我们可以分别研究拖放事件的不同部分。 设置元素为可拖放首先，为了使元素可拖动，把 draggable 属性设置为 true ： 1&lt;img draggable=&quot;true&quot; /&gt; 拖动什么 - ondragstart 和 setData()然后，规定当元素被拖动时，会发生什么。 在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。 dataTransfer.setData() 方法设置被拖数据的数据类型和值： 1234function drag(ev)&#123;ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125; 在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。 放到何处 - ondragover ondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： 1event.preventDefault() 进行放置 - ondrop当放置被拖数据时，会发生 drop 事件。在上面的例子中，ondrop 属性调用了一个函数，drop(event)： 123456function drop(ev)&#123;ev.preventDefault();var data=ev.dataTransfer.getData(&quot;Text&quot;);ev.target.appendChild(document.getElementById(data));&#125; 代码解释： 调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 被拖数据是被拖元素的 id (“drag1”) 把被拖元素追加到放置元素（目标元素）中 四、HTML 5 Canvascanvas 元素用于在网页上绘制图形。 什么是 Canvas？ HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域，您可以控制其每一像素。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建 Canvas 元素向 HTML5 页面添加 canvas 元素。 规定元素的 id、宽度和高度： 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 通过 JavaScript 来绘制canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成： 123456&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;myCanvas&quot;);var cxt=c.getContext(&quot;2d&quot;);cxt.fillStyle=&quot;#FF0000&quot;;cxt.fillRect(0,0,150,75);&lt;/script&gt; JavaScript 使用 id 来寻找 canvas 元素： 1var c=document.getElementById(&quot;myCanvas&quot;); 然后，创建 context 对象： 1var cxt=c.getContext(&quot;2d&quot;); getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 下面的两行代码绘制一个红色的矩形： 12cxt.fillStyle=&quot;#FF0000&quot;;cxt.fillRect(0,0,150,75); fillStyle 方法将其染成红色，fillRect 方法规定了形状、位置和尺寸。 理解坐标上面的 fillRect 方法拥有参数 (0,0,150,75)。 意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 如下例所示，画布的 X 和 Y 坐标用于在画布上对绘画进行定位。 实例 HTML 5 Canvas 参考手册 五、HTML5 内联 SVG什么是SVG？ SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用于定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG 是万维网联盟的标准 SVG 的优势与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于： SVG 图像可通过文本编辑器来创建和修改 SVG 图像可被搜索、索引、脚本化或压缩 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 可以与 Java 技术一起运行 SVG 是开放的标准 SVG 文件是纯粹的 XML 浏览器支持Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持内联 SVG。 把 SVG 直接嵌入 HTML 页面在 HTML5 中，您能够将 SVG 元素直接嵌入 HTML 页面中： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt; &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 六、HTML 5 Canvas vs. SVGCanvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。 SVGSVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 CanvasCanvas 通过 JavaScript 来绘制 2D 图形。 Canvas 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较下表列出了 canvas 与 SVG 之间的一些不同之处。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 七、HTML5 地理定位定位用户的位置HTML5 Geolocation API 用于获得用户的地理位置。 鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。 浏览器支持Internet Explorer 9、Firefox、Chrome、Safari 以及 Opera 支持地理定位。 注释：对于拥有 GPS 的设备，比如 iPhone，地理定位更加精确。 HTML5 - 使用地理定位请使用 getCurrentPosition() 方法来获得用户的位置。 下例是一个简单的地理定位实例，可返回用户位置的经度和纬度。 12345678910111213141516&lt;script&gt;var x=document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else&#123;x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;&#125; &#125;function showPosition(position) &#123; x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude; &#125;&lt;/script&gt; 例子解释： 检测是否支持地理定位 如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。 如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象 showPosition() 函数获得并显示经度和纬度 上面的例子是一个非常基础的地理定位脚本，不含错误处理。 处理错误和拒绝 getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数： 123456789101112131415161718function showError(error) &#123; switch(error.code) &#123; case error.PERMISSION_DENIED: x.innerHTML=&quot;User denied the request for Geolocation.&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML=&quot;Location information is unavailable.&quot; break; case error.TIMEOUT: x.innerHTML=&quot;The request to get user location timed out.&quot; break; case error.UNKNOWN_ERROR: x.innerHTML=&quot;An unknown error occurred.&quot; break; &#125; &#125; 错误代码： Permission denied - 用户不允许地理定位 Position unavailable - 无法获取当前位置 Timeout - 操作超时 在地图中显示结果如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图： 实例 123456789function showPosition(position)&#123;var latlon=position.coords.latitude+&quot;,&quot;+position.coords.longitude;var img_url=&quot;http://maps.googleapis.com/maps/api/staticmap?center=&quot;+latlon+&quot;&amp;zoom=14&amp;size=400x300&amp;sensor=false&quot;;document.getElementById(&quot;mapholder&quot;).innerHTML=&quot;&lt;img src=&apos;&quot;+img_url+&quot;&apos; /&gt;&quot;;&#125; 在上例中，我们使用返回的经纬度数据在谷歌地图中显示位置（使用静态图像）。 给定位置的信息本页演示的是如何在地图上显示用户的位置。不过，地理定位对于给定位置的信息同样很有用处。 案例： 更新本地信息 显示用户周围的兴趣点 交互式车载导航系统 (GPS) getCurrentPosition() 方法 - 返回数据若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。 Geolocation 对象 - 其他有趣的方法watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。 clearWatch() - 停止 watchPosition() 方法 下面的例子展示 watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）： 实例 12345678910111213141516&lt;script&gt;var x=document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.watchPosition(showPosition); &#125; else&#123;x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;&#125; &#125;function showPosition(position) &#123; x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude; &#125;&lt;/script&gt; 八、HTML 5 Web 存储 在客户端存储数据HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。 HTML5 使用 JavaScript 来存储和访问数据。 localStorage 方法localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 如何创建和访问 localStorage： 实例 1234&lt;script type=&quot;text/javascript&quot;&gt;localStorage.lastname=&quot;Smith&quot;;document.write(localStorage.lastname);&lt;/script&gt; 下面的例子对用户访问页面的次数进行计数：实例 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;if (localStorage.pagecount) &#123; localStorage.pagecount=Number(localStorage.pagecount) +1; &#125;else &#123; localStorage.pagecount=1; &#125;document.write(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;);&lt;/script&gt; sessionStorage 方法sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 如何创建并访问一个 sessionStorage： 实例 1234&lt;script type=&quot;text/javascript&quot;&gt;sessionStorage.lastname=&quot;Smith&quot;;document.write(sessionStorage.lastname);&lt;/script&gt; 下面的例子对用户在当前 session 中访问页面的次数进行计数： 实例 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;if (sessionStorage.pagecount) &#123; sessionStorage.pagecount=Number(sessionStorage.pagecount) +1; &#125;else &#123; sessionStorage.pagecount=1; &#125;document.write(&quot;Visits &quot;+sessionStorage.pagecount+&quot; time(s) this session.&quot;);&lt;/script&gt; 九、HTML 5 应用程序缓存 使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。 什么是应用程序缓存（Application Cache）？HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 浏览器支持所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。 HTML5 Cache Manifest 实例下面的例子展示了带有 cache manifest 的 HTML 文档（供离线浏览）： 实例 12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt;&lt;body&gt;The content of the document......&lt;/body&gt;&lt;/html&gt; Cache Manifest 基础如需启用应用程序缓存，请在文档的 标签中包含 manifest 属性： 1234&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt;...&lt;/html&gt; 每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。 manifest 文件的建议的文件扩展名是：”.appcache”。 请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） CACHE MANIFEST第一行，CACHE MANIFEST，是必需的： 1234CACHE MANIFEST/theme.css/logo.gif/main.js 上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。 NETWORK下面的 NETWORK 小节规定文件 “login.asp” 永远不会被缓存，且离线时是不可用的： 12NETWORK:login.asp 可以使用星号来指示所有其他资源/文件都需要因特网连接： 123NETWORK:*FALLBACK 下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html5/ 目录中的所有文件： FALLBACK:/html5/ /404.html注释：第一个 URI 是资源，第二个是替补。 更新缓存 一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改（参阅下面的提示） 由程序来更新应用缓存 实例 - 完整的 Manifest 文件 1234567891011CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.aspFALLBACK:/html5/ /404.html 重要的提示：以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 关于应用程序缓存的注释 请留心缓存的内容。 一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。 注释：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 十、HTML 5 Web Workersweb worker 是运行在后台的 JavaScript，不会影响页面的性能。 什么是 Web Worker？ 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 浏览器支持所有主流浏览器均支持 web worker，除了 Internet Explorer。 检测 Web Worker 支持在创建 web worker 之前，请检测用户的浏览器是否支持它： 123456789if(typeof(Worker)!==&quot;undefined&quot;) &#123; // Yes! Web worker support! // Some code..... &#125;else &#123; // Sorry! No Web Worker support.. &#125; 创建 web worker 文件 现在，让我们在一个外部 JavaScript 中创建我们的 web worker。 在这里，我们创建了计数脚本。该脚本存储于 “demo_workers.js” 文件中： 12345678910var i=0;function timedCount()&#123;i=i+1;postMessage(i);setTimeout(&quot;timedCount()&quot;,500);&#125;timedCount(); 以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。 注释：web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。 创建 Web Worker 对象 我们已经有了 web worker 文件，现在我们需要从 HTML 页面调用它。 下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码： 1234if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; 然后我们就可以从 web worker 发生和接收消息了。 向 web worker 添加一个 “onmessage” 事件监听器： 123w.onmessage=function(event)&#123;document.getElementById(&quot;result&quot;).innerHTML=event.data;&#125;; 当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。 终止 Web Worker 当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。 如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法： 1w.terminate(); 完整的 Web Worker 实例代码 我们已经看到了 .js 文件中的 Worker 代码。下面是 HTML 页面的代码： 实例 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt;&lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;&lt;script&gt;var w;function startWorker()&#123;if(typeof(Worker)!==&quot;undefined&quot;)&#123; if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function (event) &#123; document.getElementById(&quot;result&quot;).innerHTML=event.data; &#125;;&#125;else&#123;document.getElementById(&quot;result&quot;).innerHTML=&quot;Sorry, your browser does not support Web Workers...&quot;;&#125;&#125;function stopWorker()&#123;w.terminate();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Web Workers 和 DOM 由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象： window 对象 document 对象 parent 对象 十一、HTML 5 服务器发送事件HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。 Server-Sent 事件 - 单向消息传递 Server-Sent 事件指的是网页自动获取来自服务器的更新。 以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。 例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等。 浏览器支持所有主流浏览器均支持服务器发送事件，除了 Internet Explorer。 接收 Server-Sent 事件通知EventSource 对象用于接收服务器发送事件通知： 实例 12345var source=new EventSource(&quot;demo_sse.php&quot;);source.onmessage=function(event) &#123; document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; &#125;; 例子解释： 创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”） 每接收到一次更新，就会发生 onmessage 事件 当 onmessage 事件发生时，把已接收的数据推入 id 为 “result” 的元素中 检测 Server-Sent 事件支持 在上面的 TIY 实例中，我们编写了一段额外的代码来检测服务器发送事件的浏览器支持情况： 123456789if(typeof(EventSource)!==&quot;undefined&quot;) &#123; // Yes! Server-sent events support! // Some code..... &#125;else &#123; // Sorry! No server-sent events support.. &#125; 服务器端代码实例为了让上面的例子可以运行，您还需要能够发送数据更新的服务器（比如 PHP 和 ASP）。 服务器端事件流的语法是非常简单的。把 “Content-Type” 报头设置为 “text/event-stream”。现在，您可以开始发送事件流了。 PHP 代码 (demo_sse.php)： 123456789101112131415&lt;?phpheader(&apos;Content-Type: text/event-stream&apos;);header(&apos;Cache-Control: no-cache&apos;);$time = date(&apos;r&apos;);echo &quot;data: The server time is: &#123;$time&#125;\n\n&quot;;flush();?&gt;ASP 代码 (VB) (demo_sse.asp):&lt;%Response.ContentType=&quot;text/event-stream&quot;Response.Expires=-1Response.Write(&quot;data: &quot; &amp; now())Response.Flush()%&gt; 代码解释： 把报头 “Content-Type” 设置为 “text/event-stream” 规定不对页面进行缓存 输出发送日期（始终以 “data: “ 开头） 向网页刷新输出数据 EventSource 对象 在上面的例子中，我们使用 onmessage 事件来获取消息。不过还可以使用其他事件：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript思维导图]]></title>
    <url>%2F2018%2F04%2F11%2FJavaScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图源于W3Cschool 一、数据类型 二、变量 三、运算符 四、流程语句 五、数组 六、函数基础 七、字符串函数 八、正则表达式 九、DOM基本操作 十、window对象]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试技巧总结（IMOOC）]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%EF%BC%88IMOOC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[该博客总结慕课网-快乐动起来呀老师的前端面试技巧，还请读者跳转到课程主页购买观看。 关于面试 技术面试（技术方面） 负责人面试（技术、项目深度、项目架构、业务） HR面试（性格、沟通、潜力） 大概1-1.5小时 五大部分1、面试准备2、面试技巧3、题目演练4、知识梳理5、复习指导课程价值： JD描述怎看 奖励怎么写 知识怎么复习 问题该怎么回答 项目怎么准备 和负责人怎么沟通 HR印象怎么留 课程安排面试准备 JD描述分析 ！业务分析 技术栈准备 自我介绍 模拟1面 面试技巧 页面布局类 CSS盒模型 DOM事件类 HTTP协议类 原型链类 面向对象类 通信类 前端安全 前端算法类 模拟2面 面试技巧 渲染机制 JS运行机制 页面性能 错误监控 模拟3面 面试技巧 业务能力 团队协作能力 带人能力 模拟终面 面试技巧 职业竞争力 职业规划 课程总结 注意事项 复习指南 面试模拟与技巧1、如何看待面试 我：考察面试者的基本能力 校招：偏重于校园学到的知识和能力 社招：能力=工作知识+工作经验 2、面试环节 一面：基础知识 二面/三面：基础的延伸、引导面试官 三面/四面：业务负责人–业务能力（校招一般没有） HR面：认真面对 面试准备1、职位描述（JD）分析 真正分析所面公司的职位描述（基本功-难度） 工作经验不会卡的太厉害还是看技术 准备所面公司用的技术栈 初衷 1、快速识别喜不喜欢这个岗位 2、能不能hold住这个岗位 2、业务分析或实战模拟 分析面试公司官方网站 微信小程序 3、技术栈准备 jQuery （源码：核心架构、事件委托、插件机制、兼容性） Vue（推荐！分析后的源码博客、阅读量大的） React（推荐！） Angular Node.js（花太久） 时间紧准备一个 最好有实战（遇到的问题、如何解决问题） 以上一种 一下一种 gulp（推荐） Sass less (两种预编译语言)npm grunt browserify webpack 准备所面公司用的技术 4、自我介绍简历 基本信息，姓名-年龄-手机-邮箱-籍贯 学历，博士》硕士》本科》大专 工作经历，时间-公司-岗位-职责-技术栈-业绩 开源项目，Github和说明（找开源项目、参与开源项目） 1、教育背景 2、学习经历 3、个人技能 4、工作经历自我陈述 把握面试的沟通方向 比如说喜欢研究什么网站 经常在那些网站上活跃 豁达、自信的适度发挥 自信、适度、谦虚 目的是让面试官欣赏你 实例（面试要的是你比别人聪明） 自如谈兴趣、巧妙示实例、适时讨疑问（不会就不会，但一定要以谦虚询问为结束：我该看什么资料了解这些知识，向面试官寻求资料） 节奏要适宜、切忌小聪明（多种方法解决问题会直接提升印象） 实践 方向要对，过程要细 胆子要大，心态要和 一面/二面面试技巧 准备要充分 知识要系统 沟通要简洁 内心要诚实 态度要谦虚 回答要灵活 面试模拟 一、页面布局题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各位300px，中间自适应。 1、题目真的这么简单吗（浮动、定位、Flexbox、表格布局、网格布局）2、这道题难点技巧在哪里3、这道题怎么拔高、延伸 解决方案 1、浮动（兼容性好、但脱离文档流）2、绝对定位（快速解决、之后元素脱离文档流）3、Flexbox（解决上两个方法的布局、先用最多）4、表格布局（兼容性很好、繁琐？）5、网格布局（H5新技术） 文字过多的话用3、4，不会超出范围 页面布局的变通 三栏布局 左右宽度固定，中间自适应 上下高度固定，中间自适应 两栏布局 左宽度固定，右自适应 右宽度固定，左自适应 上宽度固定，下自适应 下宽度固定，上自适应 页面布局总结 语义化掌握到位 页面布局理解深刻 CSS基础知识扎实 思维灵活且积极上进 代码书写规范 二、CSS盒模型基本概念：标准模型+IE模型标准模型和IE模型的区别 CSS如何设置两种模型 box-sizing:content-box;(默认：标准模型) box-sizing:border-box;(IE模型) JS如何设置获取盒模型对应的宽和高 dom.style.width/height dom.currentStyle.width/height window.getComputedStyle(dom).width/height dom.getBoundingClientRect().width/height 实例题（根据盒模型解释边距重叠）box.html BFC（边距重叠解决方案） BFC的基本概念：块级格式化上下文 BFC的原理：1、BFC的垂直方向会发生重叠2、BFC的区域不会与浮动元素的box重叠3、BFC是一个独立的容器，外面的元素不会影响里面的元素，反之亦然4、计算BFC高度的时候，浮动元素也会计算 如何创建BFC1、float值不为none2、position只要不是static或relative就是BFC3、display属性4、overflow BFC使用场景code： 三、DOM事件基本概念：DOM事件的级别 DOM0 element.onclick=function(){}DOM2 element.addEventListener(‘click’,function(){},false)DOM3 element.addEventListener(‘kepup’,function(){},false) DOM事件模型 捕获冒泡 DOM事件流1、捕获2、目标阶段3、冒泡 描述DOM事件捕获的具体流程 冒泡的具体流程就是倒过来 Event对象的常见应用 自定义事件code:event.html 四、HTTP协议类HTTP协议的主要特点 简单快速 灵活 无连接 无状态 HTTP报文的组成部分 HTTP方法 POST和GET的区别(重要！) HTTP状态码 什么是持久连接（打电话一个一个打还是一直通着） HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求和应答都要新建一个连接，完成后立即断开连接（HTTP协议为无连接的协议）当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的链接持续有效，当出现对服务器的后继请求时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 什么是管线化（请求打包发出-响应打包返回） 在使用持久连接的情况下，某个连接上消息的传递类似于：请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3 某个连接上的消息变成了类似这样：（请求打包发出-响应打包返回）请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3 管线化特点: 五、原型链类 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new运算符 面向对象类(oop.html) 类与实例 类的声明 生成实例 类与继承 如何实现继承 继承的几种方式!!! 通信类什么是同源策略限制（3个） 前后端如何通信（Ajax+。。。。一个不合格） Ajax WebSocket CORS 同域安全策略CORS（Cross-Origin Resource Sharing）是W3C在05年提出的跨域资源请求机制，它要求当前域（常规为存放资源的服务器）在响应报头添加Access-Control-Allow-Origin标签，从而允许指定域的站点访问当前域上的资源。 如何创建Ajax XMLHttpRequest对象的工作流程 兼容性处理 事件的出发条件 事件的触发顺序 跨域通信的几种方式!!! JSONP（原理、怎么实现的） 这个实在用到烂大街了，提起跨域实现，其实最容易想到的就是它。JSONP(JSON with Padding)是JSON的一种“使用模式”，主要是利用script标签不受同源策略限制的特性，向跨域的服务器请求并返回一段JSON数据。 常规前后端会约定好某个JSONP请求的callback名（比如随便起个名字“abc”），服务端返回的JSON数据会被这个callback名包裹起来，进而方便服务器区分收到的请求，也方便客户端区分其收到的响应数据。我们可以利用jQuery轻松实现JSONP 不过JSONP始终是无状态连接，不能获悉连接状态和错误事件，而且只能走GET的形式。 Hash location.hash/url hash 是个好东西，在之前我们曾利用avalon前端路由来实现简单的SPA页面（这篇文章），便是助力于location.hash。 利用url地址改变但不刷新页面的特性（在url： http://a.com#hello 中的 ‘#hello’ 就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递）和iframe，我们可以实现跨域传递简单信息。 Cross-document messaging(H5) 在 Cross-document messaging 中，我们可以使用 postMessage 方法和 onmessage 事件来实现不同域之间的通信，其中postMessage用于实时向接收信息的页面发送消息，其语法为： 123456otherWindow.postMessage(message, targetOrigin);//otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；//window.open的返回值；通过name或下标从window.frames取到的值。//message: 所要发送的数据，string类型。//targetOrigin: 允许通信的域的url，“*”表示不作限制。 WebSocket WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。 CORS(新标准) 安全类CSRF 基本概念和缩写 通常称为跨站请求伪造，英文名Cross-site request forgery 攻击原理 防御措施 Token验证 Referer验证 隐藏令牌 XSS 基本概念和缩写 cross-site scripting(跨域脚本 攻击) 攻击原理 防御措施 Token验证 Referer验证 隐藏令牌 WEB安全之XSS 算法类 排序！ 快速排序 选择排序 希尔排序 堆栈！、队列、链表 递归！ 递归 波兰式和逆波兰式 理论 源码 二面/三面面试技巧 知识面要广 理解要深刻 内心要诚实 态度要谦虚 回答要灵活 要学会赞美 面试模拟 渲染机制类 什么是DOCTYPE 浏览器渲染过程 重排Reflow 定义 DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。 触发Reflow 当你增加、删除、修改DOM结点时，会导致Reflow或Repaint 当你移动DOM的位置时，或者搞个动画的时候 当你修改CSS样式的时候 当你Resize窗口的时候（移动端没有这个问题），或者是滚动的时候 当你修改网页的默认字体时 重绘Repaint 定义 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为Repaint。 大白话:页面要呈现的内容，统统的画在屏幕上。 触发Repaint DOM改动 CSS改动 如何尽量减少Repaint 布局Layout 运行机制类 JavaScript 运行机制详解 如何理解JS的单线程 JS是单线程的，同一时间只能做一件事。 异步任务（队列）要挂起，先做同步任务，处理过后才相应异步任务。 12345678例一、 console.log(&apos;1&apos;); setTimeout(function()&#123; console.log(3); &#125;,0); console.log(&apos;2&apos;); 结果：1、2、3. 123456789例二、 console.log(&apos;A&apos;); while(true)&#123; &#125; console.log(&apos;B&apos;); 结果：A。 因为while是同步任务，一直在执行. 123456789101112例三、 for(var i=0;i&lt;4;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000); &#125; 结果：4、4、4、4. 因为for循环是同步任务， 所以执行for循环的时候setTimeout()函数是存在定时器中的， 并没有执行，一直到for循环执行结束后setTimeout()函数才开始执行 ---异步任务的放入队列的时间和执行时间 什么是任务队列 JavaScript 异步、栈、事件循环、任务队列 JavaScript：彻底理解同步、异步和事件循环(Event Loop) 什么是Event Loop Event Loop的规范和实现 从一道题浅说 JavaScript 的事件循环 异步任务 setTimeout和setInterval DOM事件 ES6中的Promise 总结 理解JS的单线程的概念 理解任务队列 理解Event Loop 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能类 江湖失传的最后一份CDN秘籍 异步加载 浏览器缓存 缓存的分类（会问协议头中关于缓存的字段） 强缓存(本地有缓存，不向服务器询问，直接使用缓存) Exporis（服务器的绝对时间，下发资源的时间） Cache-Control : max-age=3600（相对时间、拿到资源之后3600s之内直接使用本地资源。若两个时间都有，以Cache-Control为准） 协商缓存（和服务器协商） Last-Modified（服务器下发的） If-Modified-Since（再次请求时发出的，两值相等） Etag （哈希值，服务器第一次下发资源的时候给的，过了强缓存时间后） If-None-Match（请求时加的值，=Etag） 错误监控类 前端错误的分类 即时运行错误 try..catch window.onerror 资源加载错误 object.onerror performance.getEntries() Error时间捕获 延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？ 错误的捕获方式 上报错误的基本原理 采用Ajax通信的方式上报 利用Image对象上报 三面/四面面试技巧 准备要充分 描述要熟练 引导找时机 优势要发挥 回答要灵活 考察点 业务能力 团队协作能力 事务推动能力 带人能力 其他能力 主动描述、被动回答 我做过什么业务 独立负责。。。 负责的业务有什么业绩 历时。。。完成。。。，用户量上涨。。。 使用了什么技术方案 区别常规。。。，使用了。。。方案 突破了什么技术难点 解决了。。。 遇到了什么问题 。。。 最大的收获是什么 对业务的理解更加深入、对技术图表更有把控 团队协作能力 主动描述 协助。。。和。。。快速开发。。。 结论 一定要准备小项目！！！ 事务推动能力 主动描述 例子： 对历史算法更新换代 推动专题的CMS架构 主导克服系统的建设 完成多项专利的申请 终面面试技巧 乐观积极 主动沟通 逻辑顺畅 上进有责任心 有主张，做事果断 职业竞争力（准备好） 业务能力 可以做到行业第一 思考能力 对同一件事情可以从不同角度去思考，找到最优解 学习能力 不断学习新的业务和技术，沉淀、总结 无上限的付出 对于无法解决的问题可以熬夜、加班 职业规划（准备好） 目标是什么 在业务上成为专家，在技术上成为行业大牛 近阶段的目标 不断的学习积累各方面的经验，以学习为主 长期目标 做几件很有价值的事情，如开源作品、技术框架等 方式方法 先完成业务上的主要问题，做到极致，然后逐步向目标靠拢 课程总结 JD描述 对社招一定要看，对于校招可以忽略 简历 对照JD该写出相吻合的简历，对于未掌握的技术栈快速复习、理解 自我介绍 一定要打草稿，展示什么优势、描述什么项目，切忌临场发挥 一面 重基础、懂原理、要思考、知进退、势不可挡 二面 横向扩展、项目结合、做到有的放矢 三面 有经验、懂合作、有担当、懂规律、察言观色 终面 会沟通、要上进、好性格、有主见、强逻辑、无可挑剔 复盘 胜不骄、败不馁、总结经验、步步为营、多拿几个offer 复习指南课程中主要涉及的重点、难点，对于一些很基础的知识点没有涉及，如css选择器、HTML标签等等 对于很基础的知识点，大家可以参考W3C，把HTML、HTML5、CSS、CSS3、JavaScript等再快速看一遍，有基础的同学估计两天就能都过一遍 对于算法题，每个公司都是临时发挥，很难押题，建议还是把一些基础算法弄清楚、到时候把算法组合起来去解决问题，时间充裕的话可以刷LeetCode 堆栈、队列、链表]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CART-分类回归树]]></title>
    <url>%2F2018%2F04%2F09%2FCART-%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BD%92%E6%A0%91%2F</url>
    <content type="text"><![CDATA[CART（Classification And Regression Trees，分类回归树）算法，CART是一个独立于其他经典决策树算法的算法，所以导致CART相对来说较为复杂。因为它不仅仅可以作为分类树，还可以作为回归树。采用的是Gini指数（选Gini指数最小的特征s）作为分裂标准,同时它也是包含后剪枝操作。ID3算法和C4.5算法虽然在对训练样本集的学习中可以尽可能多地挖掘信息，但其生成的决策树分支较大，规模较大。为了简化决策树的规模，提高生成决策树的效率，就出现了根据GINI系数来选择测试属性的决策树算法CART。 一、基尼指数 定义：基尼指数（基尼不纯度）：表示在样本集合中一个随机选中的样本被分错的概率。 注意： Gini指数越小表示集合中被选中的样本被分错的概率越小，也就是说集合的纯度越高，反之，集合越不纯。 即 基尼指数（基尼不纯度）= 样本被选中的概率 * 样本被分错的概率 公式说明 pk表示选中的样本属于k类别的概率，则这个样本被分错的概率是(1-pk) 样本集合中有K个类别，一个随机选中的样本可以属于这k个类别中的任意一个，因而对类别就加和 当为二元切分法时，Gini(P) = 2p(1-p)，它易于对树构建过程进行调整以处理连续性特征。 二、基于特征A划分样本集合D之后的基尼指数需要说明的是CART是个二叉树，也就是当使用某个特征划分样本集合只有两个集合：1. 等于给定的特征值的样本集合D1 ， 2.不等于给定的特征值的样本集合D2实际上是对拥有多个取值的特征的二值处理。举个栗子🌰： 假设现在有特征 “学历”，此特征有三个特征取值： “本科”，“硕士”， “博士”， 当使用“学历”这个特征对样本集合D进行划分时，划分值分别有三个，因而有三种划分的可能集合，划分后的子集如下：1. 划分点： “本科”，划分后的子集合 ： {本科}，{硕士，博士}2. 划分点： “硕士”，划分后的子集合 ： {硕士}，{本科，博士}3. 划分点： “硕士”，划分后的子集合 ： {博士}，{本科，硕士}对于上述的每一种划分，都可以计算出基于 划分特征 = 某个特征值 将样本集合D划分为两个子集的纯度： 因而对于一个具有多个取值（超过2个）的特征，需要计算以每一个取值作为划分点，对样本D划分之后子集的纯度Gini(D,Ai)，(其中Ai 表示特征A的可能取值)然后从所有的可能划分的Gini(D,Ai)中找出Gini指数最小的划分，这个划分的划分点，便是使用特征A对样本集合D进行划分的最佳划分点。求基尼系数的含义：基尼系数宏观表达的是描述一个集合的混乱程度。基尼指数越大，表示这个样本集合D越混乱。这和熵的作用有些类似，但这仅仅是一个指数，能够判断大小，但不能像熵一样线性的量化集合中的混乱程度。——-三、CART分类生成算法 输入：训练数据集D，停止计算的条件；输出：CART决策树；根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树： 设结点的训练数据集为D，计算现有特征对该数据集的基尼指数。此时，对每一个特征A，对其可能取的每个值a，根据样本点对A=a的测试为“是”或“否”将D分割成D1和D2两部分，之后计算基尼指数。 在所有可能的特征A以及它们所有可能的切分点a中，选择基尼指数最小的特征及其对应的切分点作为最有特征与最优切分点。依照最优特征与最优切分点，从现有结点生成两个子节点，将训练数据集按照特征分配到两个子节点中去。 对两个子结点递归地调用两个子结点，将训练数据集按特征分配到两个子节点中去。 生成CART决策树。 下面用一个案例理解计算过程： 四、CART回归树算法CART生成回归树的算法是用来根据已有数据生成一个回归树，具体算法如下：这个算法比前面的那些算法要更加复杂一点，有很多公式。要想理解这个算法的作用，我们得先从感性上理解这个算法是做什么的。我们考虑最简单的最小二乘回归，CART要求我们将所有输入数据都当作在二维的平面上若干个数据点。以x轴为划分依据（也就是最后的回归树的分界线是x的值，x大于或小于某个值会判断成什么）。1. 先自己认定一组切分点（一般认为是两个点x值的中点）。然后计算这一组切分点中每一个切分点对应的均方误差，找到均方误差最小的那个切分点作为一个节点；2. 这个切分点已经将整个空间划为两块(我们只考虑最简单的二维，所以一个点代表一条垂直于x轴的线)，我们分别对这两块继续计算均方误差，找到下一个节点；3. 直到总的均方误差达到要求为止。举个栗子🌰：科普1.信息增益（ ID3算法 ） 定义： 以某特征划分数据集前后的熵的差值 在熵的理解那部分提到了，熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。划分前样本集合D的熵是一定的 ，entroy(前)，使用某个特征A划分数据集D，计算划分后的数据子集的熵 entroy(后)信息增益 = entroy(前) - entroy(后)公式: 做法：计算使用所有特征划分数据集D，得到多个特征划分数据集D的信息增益，从这些信息增益中选择最大的，因而当前结点的划分特征便是使信息增益最大的划分所使用的特征。 信息增益的理解： 对于待划分的数据集D，其 entroy(前)是一定的，但是划分之后的熵 entroy(后)是不定的，entroy(后)越小说明使用此特征划分得到的子集的不确定性越小（也就是纯度越高），因此 entroy(前) - entroy(后)差异越大，说明使用当前特征划分数据集D的话，其纯度上升的更快。而我们在构建最优的决策树的时候总希望能更快速到达纯度更高的集合，这一点可以参考优化算法中的梯度下降算法，每一步沿着负梯度方法最小化损失函数的原因就是负梯度方向是函数值减小最快的方向。同理：在决策树构建的过程中我们总是希望集合往最快到达纯度更高的子集合方向发展，因此我们总是选择使得信息增益最大的特征来划分当前数据集D。 缺点：信息增益偏向取值较多的特征 原因：当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此信息增益比较 偏向取值较多的特征。 2.信息增益比（ C4.5算法 ） 信息增益比 = 惩罚参数 * 信息增益公式： 注意：其中的HA(D)，对于样本集合D，将当前特征A作为随机变量（取值是特征A的各个特征值），求得的经验熵。（之前是把集合类别作为随机变量，现在把某个特征作为随机变量，按照此特征的特征取值对集合D进行划分，计算熵HA(D)） 信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。 惩罚参数：数据集D以特征A作为随机变量的熵的倒数，即：将特征A取值相同的样本划分到同一个子集中（之前所说数据集的熵是依据类别进行划分的） 缺点：信息增益比偏向取值较少的特征 原因：当特征取值较少时HA(D)的值较小，因此其倒数较大，因而信息增益比较大。因而偏向取值较少的特征。 使用信息增益比：基于以上缺点，并不是直接选择信息增益率最大的特征，而是现在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林]]></title>
    <url>%2F2018%2F03%2F15%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[简介:在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 Leo Breiman和Adele Cutler发展出推论出随机森林的算法。而”Random Forests”是他们的商标。这个术语是1995年由贝尔实验室的Tin Kam Ho所提出的随机决策森林（random decision forests）而来的。随机森林是通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。随机森林的名称中有两个关键词，一个是“随机”，一个就是“森林”。“森林”我们很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，这样的比喻还是很贴切的，其实这也是随机森林的主要思想–集成思想的体现。“随机”的含义我们会在下边部分讲到。 其实从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出，这就是一种最简单的 Bagging 思想。 理解：我们要将一个输入样本进行分类，我们需要将输入样本输入到每棵树中进行分类。打个形象的比喻：森林中召开会议，讨论某个动物到底是老鼠还是松鼠，每棵树都要独立地发表自己对这个问题的看法，也就是每棵树都要投票。该动物到底是老鼠还是松鼠，要依据投票情况来确定，获得票数最多的类别就是森林的分类结果。森林中的每棵树都是独立的，99.9%不相关的树做出的预测结果涵盖所有的情况，这些预测结果将会彼此抵消。少数优秀的树的预测结果将会超脱于芸芸“噪音”，做出一个好的预测。将若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器，这就是随机森林bagging的思想（关于bagging的一个有必要提及的问题：bagging的代价是不用单棵决策树来做预测，具体哪个变量起到重要作用变得未知，所以bagging改进了预测准确率但损失了解释性。）。 算法：根据下列算法而建造每棵树： 用N来表示训练用例（样本）的个数，M表示特征数目。 输入特征数目m，用于确定决策树上一个节点的决策结果；其中m应远小于M。 从N个训练用例（样本）中以有放回抽样的方式，取样N次，形成一个训练集（即bootstrap取样），并用未抽到的用例（样本）作预测，评估其误差。 对于每一个节点，随机选择m个特征，决策树上每个节点的决定都是基于这些特征确定的。根据这m个特征，计算其最佳的分裂方式。 每棵树都会完整成长而不会剪枝（Pruning，这有可能在建完一棵正常树状分类器后会被采用）。 随机森林的生成方法： 1.从样本集中通过重采样的方式产生n个样本 2.假设样本特征数目为a，对n个样本选择a中的k个特征，用建立决策树的方式获得最佳分割点 3.重复m次，产生m棵决策树 4.多数投票机制来进行预测 （需要注意的一点是，这里m是指循环的次数，n是指样本的数目，n个样本构成训练的样本集，而m次循环中又会产生m个这样的样本集） 优点:随机森林的优点有： 对于很多种数据，它可以产生高准确度的分类器。 它可以处理大量的输入变量。 它可以在决定类别时，评估变量的重要性。 在建造森林时，它可以在内部对于一般化后的误差产生不偏差的估计。 它包含一个好方法可以估计丢失的数据，并且，如果有很大一部分的数据丢失，仍可以维持准确度。 它提供一个实验方法，可以去侦测variable interactions。 对于不平衡的分类数据集来说，它可以平衡误差。 它计算各例中的亲近度，对于数据挖掘、侦测离群点（outlier）和将数据可视化非常有用。 使用上述。它可被延伸应用在未标记的数据上，这类数据通常是使用非监督式聚类。也可侦测偏离者和观看数据。 学习过程是很快速的。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入音乐视频]]></title>
    <url>%2F2018%2F03%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[随着自己在重新整理自己博客的探索中越来越深入，各种有趣的小功能越来越让我感到有趣，所以我整理了一下在文章中插入视频音乐的方法 安装插件安装hexo-tag-aplayer和hexo-tag-dplayer插件 进入站点文件夹根目录,之后安装插件 123cd blognpm install hexo-tag-aplayer --savenpm install hexo-tag-dplayer --save Hexo音乐插件详细信息：hexo-tag-aplayer中文文档真.源码：APlayerHexo视频插件纤细信息：hexo-tag-dplayer文档在文章中的用法:当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： {% aplayer "Caffeine" "Jeff Williams" "caffeine.mp3" "picture.jpg" "lrc:caffeine.txt" %} 示例：单独歌曲插入文章代码： {% aplayer "See You Again" "Wiz Khalifa" "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3" "lrc:http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.lrc" %} 效果： [ti:速度与激情-see you again] [ar:Wiz Khalifa;Charlie Puth] [al:0] [by:漫天飞羽] [offset:-500] [00:01.65]速度与激情-see you again [00:04.65]演唱：Wiz Khalifa;Charlie Puth [00:07.65]歌词by：漫天飞羽 [00:09.65] [00:11.50]It's been a long day without you my friend [00:18.10]And I'll tell you all about it when I see you again [00:24.30]We've come a long way from where we began [00:29.23]Oh I'll tell you all about it when I see you again [00:36.30]When I see you again [00:40.60]Damn who knew all the planes we flew [00:43.54]Good things we've been through [00:45.35]That I'll be standing right here [00:47.56]Talking to you about another path [00:49.65]I know we loved to hit the road and laugh [00:52.14]But something told me that it wouldn't last [00:54.32]Had to switch up look at things [00:56.24]different see the bigger picture [00:58.75]Those were the days hard work forever pays [01:01.82]Now I see you in a better place (Now I see you in a better place) [01:03.82]ah~ [01:05.00]How could we not talk about family [01:08.60]when family's all that we got? [01:09.74]Everything I went through [01:10.47]you were standing there by my side [01:12.14]And now you gonna be with me for the last ride [01:14.21]It's been a long day without you my friend [01:21.55]And I'll tell you all about it when I see you again [01:27.45]We've come a long way from where we began [01:32.00]Oh I'll tell you all about it when I see you again [01:38.50]When I see you again [01:40.50] [01:56.41]First you both go out your way [01:58.11]And the vibe is feeling strong and what's [02:00.35]Small turn to a friendship a friendship [02:02.11]Turn into a bond and that bond will never [02:04.01]Be broke and the love will never get lost (Be broke and the love will never get lost) [02:09.10]And when brotherhood come first then the line [02:11.14]Will never be crossed established it on our own [02:13.87]When that line had to be drawn and that line is what [02:16.21]We reach so remember me when I'm gone [02:21.12]How could we not talk about family [02:22.01]when family's all that we got? [02:24.14]Everything I went through you [02:25.05]were standing there by my side [02:27.70]And now you gonna be with me for the last ride [02:29.21]Let the light guide your way hold every memory [02:38.24]As you go and every road you [02:43.87]take will always lead you home [02:50.12]Hoo~ [02:53.14]It's been a long day without you my friend [03:00.48]And I'll tell you all about it when I see you again [03:06.54]We've come a long way from where we began [03:12.21]Oh I'll tell you all about it when I see you again [03:17.45]When I see you again [03:20.10] [03:23.80]Again [03:25.50] [03:30.14]When I see you again see you again [03:35.14] [03:41.54]When I see you again [03:46.45] 找歌词，上歌词千寻 www.lrcgc.com。支持歌词找歌名，LRC歌词免费下载。 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "See You Again", author: "Wiz Khalifa", url: "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3", pic: "", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 歌单插入文章代码： 123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;（随机播放）, &apos;single&apos; (单曲播放), &apos;circulation&apos; (循环播放), &apos;order&apos; (列表播放)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 效果： var options = {"narrow":false,"autoplay":false,"showlrc":3,"mutex":true,"music":[{"title":"歌曲名","author":"歌手名","url":"https://什么什么什么.mp3","pic":"https://封面图.jpg","lrc":"https://歌词.lrc"},{"title":"歌曲名","author":"歌手名","url":"https://什么什么什么.mp3","pic":"https://封面图.jpg","lrc":"https://歌词.lrc"}]}; options.element = document.getElementById("aplayer1"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 音乐的外链本来想用网易云的外链，结果发现自己喜欢的歌都因为版权无法使用外链，所以我决定使用七牛云储存音乐以及歌词 视频插入文章代码： {% dplayer "url=http://olfa3o6q1.bkt.clouddn.com/%5B4K-60FPS%5D%20Avengers%20-%20Infinity%20War%20%7C%20Official%20Trailer%20%7C%202018.mp4" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %} 效果:(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://olfa3o6q1.bkt.clouddn.com/%5B4K-60FPS%5D%20Avengers%20-%20Infinity%20War%20%7C%20Official%20Trailer%20%7C%202018.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac中常用的操作]]></title>
    <url>%2F2017%2F11%2F27%2FMac%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[显示/隐藏 隐藏文件：Command+Shift+. 再按一次即可恢复。 在终端（Terminal）输入如下命令，即可显示隐藏文件和文件defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 如需再次隐藏原本隐藏的文件和文件夹，可以输入如下命令 defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder Finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 更换JAVA版本 （控制台复制代码，更改对应版本号回车即可）export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.x.x_xxx.jdk/Contents/Home 新建Hexo文章 进入到对应博客目录 cd blog 或 cd DanterM。 新建文章文件hexo n &quot;文章名称&quot;。 部署上传文章hexo g -d]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口被占用问题]]></title>
    <url>%2F2017%2F03%2F10%2F%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[用mac学习J2EE的时候调试项目经常会出现端口被占用问题，为了方便查找，专门做了这篇简单的BLOG方便查找。 首先运行Terminal查看端口被哪个程序占用sudo lsof -i tcp:port 如： sudo lsof -i tcp:8080 找到进程的PID，将占用进程杀死sudo kill -9 PID 如：sudo kill -9 23453]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS10.12.3安装WIN10]]></title>
    <url>%2F2017%2F02%2F20%2FMac%E5%AE%89%E8%A3%85WIN10%2F</url>
    <content type="text"><![CDATA[相信很多Mac用户都会因为或多或少的原因需要安装Windows系统，但是网络上能找到的相关文章太过陈旧，只好自己摸索。这篇文章就讲解了macOS10.12.3系统安装WIN10双系统的过程以及可能碰到的问题。 第一步下载适当win10镜像，镜像在Google或者Baidu上很容易找到，下载下来即可。 第二步在下载镜像的过程中，检查安装所需，确保之后的步骤可以顺利进行。 附：Apple官网的Boot Camp助理帮助附：Apple官方文档 上面两个网页可以解决大部分的问题，但事实不是如此，我每次尝试新事物时都会被或多或少的困难折磨—-macOS sierra系统更新后多出来了许多不知道的功能，直接导致我碰上这次双系统之旅的第一只拦路虎。我的当前系统是macOS10.12.3，苹果在优化存储空间上下了很大功夫，多出来了一个“优化存储空间”的功能，导致了我的mac的存储空间中有40多G的可清除部分，以致于没有足够的空间用来安装Win10，最终通过Google解决。 解决方法如下：设置–iCloud–iCloud Drive（选项）–去掉优化Mac存储空间–重新启动（如果不行多试几次） 第三步镜像下载完成，环境所需没有问题，便可以开始第三步了。1、打开Boot Camp助理（Launchpad–其他–Boot Camp助理）2、点击继续–选择镜像–分配空间大小–继续–系统会自动下载所需文件（保持网速稳定）这时我又碰到了一个问题–您的磁盘未能分区解决方法：（当时没办法截图）重启电脑–开机时按住command+R–进入磁盘管理–如果发现Macintosh HD是灰色的话，选中后点装载后选择急救。修复后重新启动问题便解决了。 第四步之后就是简单熟悉的Windows系统安装了，一步一步来，序列号可以先跳过。进入WIN10系统–打开我的电脑进入除了系统盘的另一个盘–打开BootCamp文件夹–运行setup–结束重启–完成驱动安装。 注意安装软件以及破解系统时不要被病毒劫持主页了，很恶心很麻烦。]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Sublime Text3的汉化]]></title>
    <url>%2F2017%2F02%2F19%2FMac%E4%B8%ADSublime-Text3%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.下载汉化文件Default.sublime-package 2.打开 Sublime Text3选择Sublime Text–Preferences–Browse Packages点开后会自动打开Finder 如下图 3.找到Installed Packages点击图中上方的Installed Packages 如下图 4.复制文件到Installed Packages中将下载的Default.sublime-package放在Installed Packages文件夹中 3.完成汉化]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred中Workflow的简单案例--新建文件]]></title>
    <url>%2F2017%2F02%2F15%2FAlfred%E4%B8%ADWorkflow%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B--%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[从头构建一个“新建文件”功能的workflow文件自从使用了macbook之后，我便在网络上大量搜索能够有效提高效率的软件，大部分人的推荐都会有一个叫做Alfred的应用,这篇文章讲解了一个简单的alfredworkflow是如何写出来的。 什么是Alfred?Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac. 点击进入Alfred官网Workflow汇总 直切主题，有自己写workflow想法的你肯定已经知道什么是Alfred、怎么使用Alfred，但实际上自己写一个workflow真的很简单。下面我会一步一步的整理出我是如何写出这一简单的功能的。 1.设置Workflow Defaults1.1打开Alfred打开Alfred的Workflow，点击左下角的加号。 1.2填写基本信息 2.创建Blank Workflow2.1新建Blank Workflow 2.2填写信息分别为workflow名称、功能描述、功能分类，图中右上角的方框是workflow的Icon，支持拖拽找到图片直接拖进去即可。 2.3得到workflow界面 3.制作Workflow3.1 新建Inputs在界面上右键得到如下图结果，选择Inputs中的Keyword 3.1.1 填写自定义信息得到如下图结果，填写你想要设置的 激活词组 、标题以及简介，我这里定义成new。 3.1.2实际使用演示 3.2 新建Actions在界面上右键得到如下图结果，选择Actions中的Run NSAppleScript 3.2.1 编辑代码双击得到如下图结果，接着双击转到代码编辑页面将your script here更换成你想要实现的功能的代码即可,当然此处只能用Apple的script来写。 此处我的代码是 on alfred_script(q) tell application &quot;Finder&quot; set selection to make new file at (get insertion location) end tell end alfred_script 如果想用其他语言在请选择在3.2时选择Run Script即可，可以自己选择所用语言，如下图 3.2.2连接模块 4.结果 5.附导出文件new-file.alfredworkflow]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法简介]]></title>
    <url>%2F2017%2F02%2F15%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[主要内容以下内容来源于younghz的Github Markdown是什么？谁发明了这么个东西？为什么要使用它？怎么使用？都谁在用？感觉有意思？不怕你看见，就怕你试试 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. _谁_发明了这么个东西？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案居然被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途（又是一位犹太人）。 3. 为什么要使用它？ 它是易读（看起开舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰的组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. _怎么_使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 废话太多，下面正文，Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); } 注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，_斜体_粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 都_谁_在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 感觉有意思？趁热打铁，推荐几个_工具_。 Chrome下的stackedit插件可以离线使用，很爽。也不用担心平台受限。在线的dillinger.io算是评价好的了，可是不能离线使用。 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。推荐。 Linux下的ReText不错。 其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。我现在使用马克飞象 + Markdown-here，先编辑好，然后一键格式化，挺方便。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。 以上基本是所有traditonal markdown的语法。 补充：随着macOS 10.12的更新，Mou已经无法在新系统上使用，推荐的Markdown编辑器有MWeb、Ulysses、Byword等。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>优秀文章</tag>
      </tags>
  </entry>
</search>
