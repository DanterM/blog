<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript思维导图]]></title>
    <url>%2F2018%2F04%2F11%2FJavaScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、数据类型 二、变量 三、运算符 四、流程语句 五、数组 六、函数基础 七、字符串函数 八、正则表达式 九、DOM基本操作 十、window对象]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试技巧总结（IMOOC）]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于面试 技术面试（技术方面） 负责人面试（技术、项目深度、项目架构、业务） HR面试（性格、沟通、潜力） 大概1-1.5小时 五大部分1、面试准备2、面试技巧3、题目演练4、知识梳理5、复习指导课程价值： JD描述怎看 奖励怎么写 知识怎么复习 问题该怎么回答 项目怎么准备 和负责人怎么沟通 HR印象怎么留 课程安排面试准备 JD描述分析 ！业务分析 技术栈准备 自我介绍 模拟1面 面试技巧 页面布局类 CSS盒模型 DOM事件类 HTTP协议类 原型链类 面向对象类 通信类 前端安全 前端算法类 模拟2面 面试技巧 渲染机制 JS运行机制 页面性能 错误监控 模拟3面 面试技巧 业务能力 团队协作能力 带人能力 模拟终面 面试技巧 职业竞争力 职业规划 课程总结 注意事项 复习指南 面试模拟与技巧1、如何看待面试 我：考察面试者的基本能力 校招：偏重于校园学到的知识和能力 社招：能力=工作知识+工作经验 2、面试环节 一面：基础知识 二面/三面：基础的延伸、引导面试官 三面/四面：业务负责人–业务能力（校招一般没有） HR面：认真面对 面试准备1、职位描述（JD）分析 真正分析所面公司的职位描述（基本功-难度） 工作经验不会卡的太厉害还是看技术 准备所面公司用的技术栈 初衷 1、快速识别喜不喜欢这个岗位 2、能不能hold住这个岗位 2、业务分析或实战模拟 分析面试公司官方网站 微信小程序 3、技术栈准备 jQuery （源码：核心架构、事件委托、插件机制、兼容性） Vue（推荐！分析后的源码博客、阅读量大的） React（推荐！） Angular Node.js（花太久） 时间紧准备一个 最好有实战（遇到的问题、如何解决问题） 以上一种 一下一种 gulp（推荐） Sass less (两种预编译语言)npm grunt browserify webpack 准备所面公司用的技术 4、自我介绍简历 基本信息，姓名-年龄-手机-邮箱-籍贯 学历，博士》硕士》本科》大专 工作经历，时间-公司-岗位-职责-技术栈-业绩 开源项目，Github和说明（找开源项目、参与开源项目） 1、教育背景 2、学习经历 3、个人技能 4、工作经历自我陈述 把握面试的沟通方向 比如说喜欢研究什么网站 经常在那些网站上活跃 豁达、自信的适度发挥 自信、适度、谦虚 目的是让面试官欣赏你 实例（面试要的是你比别人聪明） 自如谈兴趣、巧妙示实例、适时讨疑问（不会就不会，但一定要以谦虚询问为结束：我该看什么资料了解这些知识，向面试官寻求资料） 节奏要适宜、切忌小聪明（多种方法解决问题会直接提升印象） 实践 方向要对，过程要细 胆子要大，心态要和 一面/二面面试技巧 准备要充分 知识要系统 沟通要简洁 内心要诚实 态度要谦虚 回答要灵活 面试模拟 一、页面布局题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各位300px，中间自适应。 1、题目真的这么简单吗（浮动、定位、Flexbox、表格布局、网格布局）2、这道题难点技巧在哪里3、这道题怎么拔高、延伸 解决方案 1、浮动（兼容性好、但脱离文档流）2、绝对定位（快速解决、之后元素脱离文档流）3、Flexbox（解决上两个方法的布局、先用最多）4、表格布局（兼容性很好、繁琐？）5、网格布局（H5新技术） 文字过多的话用3、4，不会超出范围 页面布局的变通 三栏布局 左右宽度固定，中间自适应 上下高度固定，中间自适应 两栏布局 左宽度固定，右自适应 右宽度固定，左自适应 上宽度固定，下自适应 下宽度固定，上自适应 页面布局总结 语义化掌握到位 页面布局理解深刻 CSS基础知识扎实 思维灵活且积极上进 代码书写规范 二、CSS盒模型基本概念：标准模型+IE模型标准模型和IE模型的区别 CSS如何设置两种模型 box-sizing:content-box;(默认：标准模型) box-sizing:border-box;(IE模型) JS如何设置获取盒模型对应的宽和高 dom.style.width/height dom.currentStyle.width/height window.getComputedStyle(dom).width/height dom.getBoundingClientRect().width/height 实例题（根据盒模型解释边距重叠）box.html BFC（边距重叠解决方案） BFC的基本概念：块级格式化上下文 BFC的原理：1、BFC的垂直方向会发生重叠2、BFC的区域不会与浮动元素的box重叠3、BFC是一个独立的容器，外面的元素不会影响里面的元素，反之亦然4、计算BFC高度的时候，浮动元素也会计算 如何创建BFC1、float值不为none2、position只要不是static或relative就是BFC3、display属性4、overflow BFC使用场景code： 三、DOM事件基本概念：DOM事件的级别 DOM0 element.onclick=function(){}DOM2 element.addEventListener(‘click’,function(){},false)DOM3 element.addEventListener(‘kepup’,function(){},false) DOM事件模型 捕获冒泡 DOM事件流1、捕获2、目标阶段3、冒泡 描述DOM事件捕获的具体流程 冒泡的具体流程就是倒过来 Event对象的常见应用 自定义事件code:event.html 四、HTTP协议类HTTP协议的主要特点 简单快速 灵活 无连接 无状态 HTTP报文的组成部分 HTTP方法 POST和GET的区别 HTTP状态码什么是持久连接什么是管线化]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CART.py]]></title>
    <url>%2F2018%2F04%2F10%2FCART-py%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#!/usr/bin/env python# encoding: utf-8&quot;&quot;&quot;@author: @software: python@file: CART.py@desc: 决策树(CART)， 分类回归树@hint:&quot;&quot;&quot;# setosa 山鸢尾# versicolor 多色鸢尾# virginica 维吉尼亚鸢尾import numpy as npclass Tree: def __init__(self, value=None, trueBranch=None, falseBranch=None, results=None, col=-1, summary=None, data=None): self.value = value self.trueBranch = trueBranch self.falseBranch = falseBranch self.results = results self.col = col self.summary = summary self.data = data def __str__(self): print(self.col, self.value) print(self.results) print(self.summary) return &quot;&quot;def calculateDiffCount(datas): # 将输入的数据汇总(input, dataSet) # return results Set&#123;type1:type1Count, type2:type2Count .... typeN:typeNCount&#125; &quot;&quot;&quot; 该函数是计算gini值的辅助函数，假设输入的dataSet为为[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;A&apos;, &apos;A&apos;, &apos;D&apos;]， 则输出为[&apos;A&apos;:3,&apos; B&apos;:1, &apos;C&apos;:1, &apos;D&apos;:1]，这样分类统计dataSet中每个类别的数量 &quot;&quot;&quot; results = &#123;&#125; for data in datas: # data[-1] means dataType if data[-1] not in results: results.setdefault(data[-1], 1) else: results[data[-1]] += 1 return results# gini()def gini(rows): # 计算gini的值(Calculate GINI) length = len(rows) results = calculateDiffCount(rows) imp = 0.0 for i in results: imp += results[i] / length * results[i] / length return 1 - impdef splitDatas(rows, value, column): # 根据条件分离数据集(splitDatas by value, column) # return 2 part（list1, list2） list1 = [] list2 = [] if isinstance(value, int) or isinstance(value, float): for row in rows: if row[column] &gt;= value: list1.append(row) else: list2.append(row) else: for row in rows: if row[column] == value: list1.append(row) else: list2.append(row) return list1, list2def buildDecisionTree(rows, evaluationFunction=gini): # 递归建立决策树， 当gain=0，时停止回归 # build decision tree bu recursive function # stop recursive function when gain = 0 # return tree currentGain = evaluationFunction(rows) column_lenght = len(rows[0]) rows_length = len(rows) best_gain = 0.0 best_value = None best_set = None # choose the best gain for col in range(column_lenght - 1): col_value_set = set([x[col] for x in rows]) for value in col_value_set: list1, list2 = splitDatas(rows, value, col) p = len(list1) / rows_length gain = currentGain - p * evaluationFunction(list1) - (1 - p) * evaluationFunction(list2) if gain &gt; best_gain: best_gain = gain best_value = (col, value) best_set = (list1, list2) dcY = &#123;&apos;impurity&apos;: &apos;%.3f&apos; % currentGain, &apos;sample&apos;: &apos;%d&apos; % rows_length&#125; # # stop or not stop if best_gain &gt; 0: trueBranch = buildDecisionTree(best_set[0], evaluationFunction) falseBranch = buildDecisionTree(best_set[1], evaluationFunction) return Tree(col=best_value[0], value = best_value[1], trueBranch = trueBranch, falseBranch=falseBranch, summary=dcY) else: return Tree(results=calculateDiffCount(rows), summary=dcY, data=rows)def prune(tree, miniGain, evaluationFunction=gini): # 剪枝 when gain &lt; mini Gain, 合并（merge the trueBranch and falseBranch） if tree.trueBranch.results == None: prune(tree.trueBranch, miniGain, evaluationFunction) if tree.falseBranch.results == None: prune(tree.falseBranch, miniGain, evaluationFunction) if tree.trueBranch.results != None and tree.falseBranch.results != None: len1 = len(tree.trueBranch.data) len2 = len(tree.falseBranch.data) len3 = len(tree.trueBranch.data + tree.falseBranch.data) p = float(len1) / (len1 + len2) gain = evaluationFunction(tree.trueBranch.data + tree.falseBranch.data) - p * evaluationFunction(tree.trueBranch.data) - (1 - p) * evaluationFunction(tree.falseBranch.data) if gain &lt; miniGain: tree.data = tree.trueBranch.data + tree.falseBranch.data tree.results = calculateDiffCount(tree.data) tree.trueBranch = None tree.falseBranch = Nonedef classify(data, tree): if tree.results != None: return tree.results else: branch = None v = data[tree.col] if isinstance(v, int) or isinstance(v, float): if v &gt;= tree.value: branch = tree.trueBranch else: branch = tree.falseBranch else: if v == tree.value: branch = tree.trueBranch else: branch = tree.falseBranch return classify(data, branch)def loadCSV(): def convertTypes(s): s = s.strip() try: return float(s) if &apos;.&apos; in s else int(s) except ValueError: return s data = np.loadtxt(&quot;datas.csv&quot;, dtype=&apos;str&apos;, delimiter=&apos;,&apos;) data = data[1:, :] dataSet =([[convertTypes(item) for item in row] for row in data]) return dataSet# 画树if __name__ == &apos;__main__&apos;: dataSet = loadCSV() decisionTree = buildDecisionTree(dataSet, evaluationFunction=gini) prune(decisionTree, 0.4) # test_data = [5.9,3,4.2,1.5] test_data = [7, 3.2, 4.7, 1.4] r = classify(test_data, decisionTree) print(r)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CART-分类回归树]]></title>
    <url>%2F2018%2F04%2F09%2FCART-%E5%88%86%E7%B1%BB%E5%9B%9E%E5%BD%92%E6%A0%91%2F</url>
    <content type="text"><![CDATA[CART（Classification And Regression Trees，分类回归树）算法，CART是一个独立于其他经典决策树算法的算法，所以导致CART相对来说较为复杂。因为它不仅仅可以作为分类树，还可以作为回归树。采用的是Gini指数（选Gini指数最小的特征s）作为分裂标准,同时它也是包含后剪枝操作。ID3算法和C4.5算法虽然在对训练样本集的学习中可以尽可能多地挖掘信息，但其生成的决策树分支较大，规模较大。为了简化决策树的规模，提高生成决策树的效率，就出现了根据GINI系数来选择测试属性的决策树算法CART。 一、基尼指数 定义：基尼指数（基尼不纯度）：表示在样本集合中一个随机选中的样本被分错的概率。 注意： Gini指数越小表示集合中被选中的样本被分错的概率越小，也就是说集合的纯度越高，反之，集合越不纯。 即 基尼指数（基尼不纯度）= 样本被选中的概率 * 样本被分错的概率 公式说明 pk表示选中的样本属于k类别的概率，则这个样本被分错的概率是(1-pk) 样本集合中有K个类别，一个随机选中的样本可以属于这k个类别中的任意一个，因而对类别就加和 当为二元切分法时，Gini(P) = 2p(1-p)，它易于对树构建过程进行调整以处理连续性特征。 二、基于特征A划分样本集合D之后的基尼指数需要说明的是CART是个二叉树，也就是当使用某个特征划分样本集合只有两个集合：1. 等于给定的特征值的样本集合D1 ， 2.不等于给定的特征值的样本集合D2实际上是对拥有多个取值的特征的二值处理。举个栗子🌰： 假设现在有特征 “学历”，此特征有三个特征取值： “本科”，“硕士”， “博士”， 当使用“学历”这个特征对样本集合D进行划分时，划分值分别有三个，因而有三种划分的可能集合，划分后的子集如下：1. 划分点： “本科”，划分后的子集合 ： {本科}，{硕士，博士}2. 划分点： “硕士”，划分后的子集合 ： {硕士}，{本科，博士}3. 划分点： “硕士”，划分后的子集合 ： {博士}，{本科，硕士}对于上述的每一种划分，都可以计算出基于 划分特征 = 某个特征值 将样本集合D划分为两个子集的纯度： 因而对于一个具有多个取值（超过2个）的特征，需要计算以每一个取值作为划分点，对样本D划分之后子集的纯度Gini(D,Ai)，(其中Ai 表示特征A的可能取值)然后从所有的可能划分的Gini(D,Ai)中找出Gini指数最小的划分，这个划分的划分点，便是使用特征A对样本集合D进行划分的最佳划分点。求基尼系数的含义：基尼系数宏观表达的是描述一个集合的混乱程度。基尼指数越大，表示这个样本集合D越混乱。这和熵的作用有些类似，但这仅仅是一个指数，能够判断大小，但不能像熵一样线性的量化集合中的混乱程度。——-三、CART分类生成算法 输入：训练数据集D，停止计算的条件；输出：CART决策树；根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树： 设结点的训练数据集为D，计算现有特征对该数据集的基尼指数。此时，对每一个特征A，对其可能取的每个值a，根据样本点对A=a的测试为“是”或“否”将D分割成D1和D2两部分，之后计算基尼指数。 在所有可能的特征A以及它们所有可能的切分点a中，选择基尼指数最小的特征及其对应的切分点作为最有特征与最优切分点。依照最优特征与最优切分点，从现有结点生成两个子节点，将训练数据集按照特征分配到两个子节点中去。 对两个子结点递归地调用两个子结点，将训练数据集按特征分配到两个子节点中去。 生成CART决策树。 下面用一个案例理解计算过程： 四、CART回归树算法CART生成回归树的算法是用来根据已有数据生成一个回归树，具体算法如下：这个算法比前面的那些算法要更加复杂一点，有很多公式。要想理解这个算法的作用，我们得先从感性上理解这个算法是做什么的。我们考虑最简单的最小二乘回归，CART要求我们将所有输入数据都当作在二维的平面上若干个数据点。以x轴为划分依据（也就是最后的回归树的分界线是x的值，x大于或小于某个值会判断成什么）。1. 先自己认定一组切分点（一般认为是两个点x值的中点）。然后计算这一组切分点中每一个切分点对应的均方误差，找到均方误差最小的那个切分点作为一个节点；2. 这个切分点已经将整个空间划为两块(我们只考虑最简单的二维，所以一个点代表一条垂直于x轴的线)，我们分别对这两块继续计算均方误差，找到下一个节点；3. 直到总的均方误差达到要求为止。举个栗子🌰：科普1.信息增益（ ID3算法 ） 定义： 以某特征划分数据集前后的熵的差值 在熵的理解那部分提到了，熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。划分前样本集合D的熵是一定的 ，entroy(前)，使用某个特征A划分数据集D，计算划分后的数据子集的熵 entroy(后)信息增益 = entroy(前) - entroy(后)公式: 做法：计算使用所有特征划分数据集D，得到多个特征划分数据集D的信息增益，从这些信息增益中选择最大的，因而当前结点的划分特征便是使信息增益最大的划分所使用的特征。 信息增益的理解： 对于待划分的数据集D，其 entroy(前)是一定的，但是划分之后的熵 entroy(后)是不定的，entroy(后)越小说明使用此特征划分得到的子集的不确定性越小（也就是纯度越高），因此 entroy(前) - entroy(后)差异越大，说明使用当前特征划分数据集D的话，其纯度上升的更快。而我们在构建最优的决策树的时候总希望能更快速到达纯度更高的集合，这一点可以参考优化算法中的梯度下降算法，每一步沿着负梯度方法最小化损失函数的原因就是负梯度方向是函数值减小最快的方向。同理：在决策树构建的过程中我们总是希望集合往最快到达纯度更高的子集合方向发展，因此我们总是选择使得信息增益最大的特征来划分当前数据集D。 缺点：信息增益偏向取值较多的特征 原因：当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此信息增益比较 偏向取值较多的特征。 2.信息增益比（ C4.5算法 ） 信息增益比 = 惩罚参数 * 信息增益公式： 注意：其中的HA(D)，对于样本集合D，将当前特征A作为随机变量（取值是特征A的各个特征值），求得的经验熵。（之前是把集合类别作为随机变量，现在把某个特征作为随机变量，按照此特征的特征取值对集合D进行划分，计算熵HA(D)） 信息增益比本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。 惩罚参数：数据集D以特征A作为随机变量的熵的倒数，即：将特征A取值相同的样本划分到同一个子集中（之前所说数据集的熵是依据类别进行划分的） 缺点：信息增益比偏向取值较少的特征 原因：当特征取值较少时HA(D)的值较小，因此其倒数较大，因而信息增益比较大。因而偏向取值较少的特征。 使用信息增益比：基于以上缺点，并不是直接选择信息增益率最大的特征，而是现在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林]]></title>
    <url>%2F2018%2F03%2F15%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[简介:在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 Leo Breiman和Adele Cutler发展出推论出随机森林的算法。而”Random Forests”是他们的商标。这个术语是1995年由贝尔实验室的Tin Kam Ho所提出的随机决策森林（random decision forests）而来的。随机森林是通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。随机森林的名称中有两个关键词，一个是“随机”，一个就是“森林”。“森林”我们很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，这样的比喻还是很贴切的，其实这也是随机森林的主要思想–集成思想的体现。“随机”的含义我们会在下边部分讲到。 其实从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出，这就是一种最简单的 Bagging 思想。 理解：我们要将一个输入样本进行分类，我们需要将输入样本输入到每棵树中进行分类。打个形象的比喻：森林中召开会议，讨论某个动物到底是老鼠还是松鼠，每棵树都要独立地发表自己对这个问题的看法，也就是每棵树都要投票。该动物到底是老鼠还是松鼠，要依据投票情况来确定，获得票数最多的类别就是森林的分类结果。森林中的每棵树都是独立的，99.9%不相关的树做出的预测结果涵盖所有的情况，这些预测结果将会彼此抵消。少数优秀的树的预测结果将会超脱于芸芸“噪音”，做出一个好的预测。将若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器，这就是随机森林bagging的思想（关于bagging的一个有必要提及的问题：bagging的代价是不用单棵决策树来做预测，具体哪个变量起到重要作用变得未知，所以bagging改进了预测准确率但损失了解释性。）。 算法：根据下列算法而建造每棵树： 用N来表示训练用例（样本）的个数，M表示特征数目。 输入特征数目m，用于确定决策树上一个节点的决策结果；其中m应远小于M。 从N个训练用例（样本）中以有放回抽样的方式，取样N次，形成一个训练集（即bootstrap取样），并用未抽到的用例（样本）作预测，评估其误差。 对于每一个节点，随机选择m个特征，决策树上每个节点的决定都是基于这些特征确定的。根据这m个特征，计算其最佳的分裂方式。 每棵树都会完整成长而不会剪枝（Pruning，这有可能在建完一棵正常树状分类器后会被采用）。 随机森林的生成方法： 1.从样本集中通过重采样的方式产生n个样本 2.假设样本特征数目为a，对n个样本选择a中的k个特征，用建立决策树的方式获得最佳分割点 3.重复m次，产生m棵决策树 4.多数投票机制来进行预测 （需要注意的一点是，这里m是指循环的次数，n是指样本的数目，n个样本构成训练的样本集，而m次循环中又会产生m个这样的样本集） 优点:随机森林的优点有： 对于很多种数据，它可以产生高准确度的分类器。 它可以处理大量的输入变量。 它可以在决定类别时，评估变量的重要性。 在建造森林时，它可以在内部对于一般化后的误差产生不偏差的估计。 它包含一个好方法可以估计丢失的数据，并且，如果有很大一部分的数据丢失，仍可以维持准确度。 它提供一个实验方法，可以去侦测variable interactions。 对于不平衡的分类数据集来说，它可以平衡误差。 它计算各例中的亲近度，对于数据挖掘、侦测离群点（outlier）和将数据可视化非常有用。 使用上述。它可被延伸应用在未标记的数据上，这类数据通常是使用非监督式聚类。也可侦测偏离者和观看数据。 学习过程是很快速的。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入音乐视频]]></title>
    <url>%2F2018%2F03%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[随着自己在重新整理自己博客的探索中越来越深入，各种有趣的小功能越来越让我感到有趣，所以我整理了一下在文章中插入视频音乐的方法 安装插件安装hexo-tag-aplayer和hexo-tag-dplayer插件 进入站点文件夹根目录,之后安装插件 123cd blognpm install hexo-tag-aplayer --savenpm install hexo-tag-dplayer --save Hexo音乐插件详细信息：hexo-tag-aplayer中文文档真.源码：APlayerHexo视频插件纤细信息：hexo-tag-dplayer文档在文章中的用法:当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： {% aplayer "Caffeine" "Jeff Williams" "caffeine.mp3" "picture.jpg" "lrc:caffeine.txt" %} 示例：单独歌曲插入文章代码： {% aplayer "See You Again" "Wiz Khalifa" "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3" "lrc:http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.lrc" %} 效果： [ti:速度与激情-see you again] [ar:Wiz Khalifa;Charlie Puth] [al:0] [by:漫天飞羽] [offset:-500] [00:01.65]速度与激情-see you again [00:04.65]演唱：Wiz Khalifa;Charlie Puth [00:07.65]歌词by：漫天飞羽 [00:09.65] [00:11.50]It's been a long day without you my friend [00:18.10]And I'll tell you all about it when I see you again [00:24.30]We've come a long way from where we began [00:29.23]Oh I'll tell you all about it when I see you again [00:36.30]When I see you again [00:40.60]Damn who knew all the planes we flew [00:43.54]Good things we've been through [00:45.35]That I'll be standing right here [00:47.56]Talking to you about another path [00:49.65]I know we loved to hit the road and laugh [00:52.14]But something told me that it wouldn't last [00:54.32]Had to switch up look at things [00:56.24]different see the bigger picture [00:58.75]Those were the days hard work forever pays [01:01.82]Now I see you in a better place (Now I see you in a better place) [01:03.82]ah~ [01:05.00]How could we not talk about family [01:08.60]when family's all that we got? [01:09.74]Everything I went through [01:10.47]you were standing there by my side [01:12.14]And now you gonna be with me for the last ride [01:14.21]It's been a long day without you my friend [01:21.55]And I'll tell you all about it when I see you again [01:27.45]We've come a long way from where we began [01:32.00]Oh I'll tell you all about it when I see you again [01:38.50]When I see you again [01:40.50] [01:56.41]First you both go out your way [01:58.11]And the vibe is feeling strong and what's [02:00.35]Small turn to a friendship a friendship [02:02.11]Turn into a bond and that bond will never [02:04.01]Be broke and the love will never get lost (Be broke and the love will never get lost) [02:09.10]And when brotherhood come first then the line [02:11.14]Will never be crossed established it on our own [02:13.87]When that line had to be drawn and that line is what [02:16.21]We reach so remember me when I'm gone [02:21.12]How could we not talk about family [02:22.01]when family's all that we got? [02:24.14]Everything I went through you [02:25.05]were standing there by my side [02:27.70]And now you gonna be with me for the last ride [02:29.21]Let the light guide your way hold every memory [02:38.24]As you go and every road you [02:43.87]take will always lead you home [02:50.12]Hoo~ [02:53.14]It's been a long day without you my friend [03:00.48]And I'll tell you all about it when I see you again [03:06.54]We've come a long way from where we began [03:12.21]Oh I'll tell you all about it when I see you again [03:17.45]When I see you again [03:20.10] [03:23.80]Again [03:25.50] [03:30.14]When I see you again see you again [03:35.14] [03:41.54]When I see you again [03:46.45] 找歌词，上歌词千寻 www.lrcgc.com。支持歌词找歌名，LRC歌词免费下载。 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "See You Again", author: "Wiz Khalifa", url: "http://olfa3o6q1.bkt.clouddn.com/See%20You%20Again.mp3", pic: "", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 歌单插入文章代码： 123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, // （可选）播放器袖珍风格 &quot;autoplay&quot;: true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;, // （可选）曲目循环类型，有 &apos;random&apos;（随机播放）, &apos;single&apos; (单曲播放), &apos;circulation&apos; (循环播放), &apos;order&apos; (列表播放)， 默认：&apos;circulation&apos; &quot;showlrc&quot;: 3, // （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;, // （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;, // （可选）音乐文件预载入模式，可选项： &apos;none&apos; &apos;metadata&apos; &apos;auto&apos;, 默认: &apos;auto&apos; &quot;listmaxheight&quot;: &quot;513px&quot;, // (可选) 该播放列表的最大长度 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;CoCo&quot;, &quot;author&quot;: &quot;Jeff Williams&quot;, &quot;url&quot;: &quot;caffeine.mp3&quot;, &quot;pic&quot;: &quot;caffeine.jpeg&quot;, &quot;lrc&quot;: &quot;caffeine.txt&quot; &#125;, &#123; &quot;title&quot;: &quot;アイロニ&quot;, &quot;author&quot;: &quot;鹿乃&quot;, &quot;url&quot;: &quot;irony.mp3&quot;, &quot;pic&quot;: &quot;irony.jpg&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 效果： var options = {"narrow":false,"autoplay":false,"showlrc":3,"mutex":true,"music":[{"title":"歌曲名","author":"歌手名","url":"https://什么什么什么.mp3","pic":"https://封面图.jpg","lrc":"https://歌词.lrc"},{"title":"歌曲名","author":"歌手名","url":"https://什么什么什么.mp3","pic":"https://封面图.jpg","lrc":"https://歌词.lrc"}]}; options.element = document.getElementById("aplayer1"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 音乐的外链本来想用网易云的外链，结果发现自己喜欢的歌都因为版权无法使用外链，所以我决定使用七牛云储存音乐以及歌词 视频插入文章代码： {% dplayer "url=http://olfa3o6q1.bkt.clouddn.com/%5B4K-60FPS%5D%20Avengers%20-%20Infinity%20War%20%7C%20Official%20Trailer%20%7C%202018.mp4" "api=https://api.prprpr.me/dplayer/" "id=" "loop=false" %} 效果:(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://olfa3o6q1.bkt.clouddn.com/%5B4K-60FPS%5D%20Avengers%20-%20Infinity%20War%20%7C%20Official%20Trailer%20%7C%202018.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac中常用的操作]]></title>
    <url>%2F2017%2F11%2F27%2FMac%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[显示/隐藏 隐藏文件：Command+Shift+. 再按一次即可恢复。 在终端（Terminal）输入如下命令，即可显示隐藏文件和文件defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 如需再次隐藏原本隐藏的文件和文件夹，可以输入如下命令 defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder Finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 更换JAVA版本 （控制台复制代码，更改对应版本号回车即可）export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.x.x_xxx.jdk/Contents/Home 新建Hexo文章 进入到对应博客目录 cd blog 或 cd DanterM。 新建文章文件hexo n &quot;文章名称&quot;。 部署上传文章hexo g -d]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口被占用问题]]></title>
    <url>%2F2017%2F03%2F10%2F%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[用mac学习J2EE的时候调试项目经常会出现端口被占用问题，为了方便查找，专门做了这篇简单的BLOG方便查找。 首先运行Terminal查看端口被哪个程序占用sudo lsof -i tcp:port 如： sudo lsof -i tcp:8080 找到进程的PID，将占用进程杀死sudo kill -9 PID 如：sudo kill -9 23453]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS10.12.3安装WIN10]]></title>
    <url>%2F2017%2F02%2F20%2FMac%E5%AE%89%E8%A3%85WIN10%2F</url>
    <content type="text"><![CDATA[相信很多Mac用户都会因为或多或少的原因需要安装Windows系统，但是网络上能找到的相关文章太过陈旧，只好自己摸索。这篇文章就讲解了macOS10.12.3系统安装WIN10双系统的过程以及可能碰到的问题。 第一步下载适当win10镜像，镜像在Google或者Baidu上很容易找到，下载下来即可。 第二步在下载镜像的过程中，检查安装所需，确保之后的步骤可以顺利进行。 附：Apple官网的Boot Camp助理帮助附：Apple官方文档 上面两个网页可以解决大部分的问题，但事实不是如此，我每次尝试新事物时都会被或多或少的困难折磨—-macOS sierra系统更新后多出来了许多不知道的功能，直接导致我碰上这次双系统之旅的第一只拦路虎。我的当前系统是macOS10.12.3，苹果在优化存储空间上下了很大功夫，多出来了一个“优化存储空间”的功能，导致了我的mac的存储空间中有40多G的可清除部分，以致于没有足够的空间用来安装Win10，最终通过Google解决。 解决方法如下：设置–iCloud–iCloud Drive（选项）–去掉优化Mac存储空间–重新启动（如果不行多试几次） 第三步镜像下载完成，环境所需没有问题，便可以开始第三步了。1、打开Boot Camp助理（Launchpad–其他–Boot Camp助理）2、点击继续–选择镜像–分配空间大小–继续–系统会自动下载所需文件（保持网速稳定）这时我又碰到了一个问题–您的磁盘未能分区解决方法：（当时没办法截图）重启电脑–开机时按住command+R–进入磁盘管理–如果发现Macintosh HD是灰色的话，选中后点装载后选择急救。修复后重新启动问题便解决了。 第四步之后就是简单熟悉的Windows系统安装了，一步一步来，序列号可以先跳过。进入WIN10系统–打开我的电脑进入除了系统盘的另一个盘–打开BootCamp文件夹–运行setup–结束重启–完成驱动安装。 注意安装软件以及破解系统时不要被病毒劫持主页了，很恶心很麻烦。]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Sublime Text3的汉化]]></title>
    <url>%2F2017%2F02%2F19%2FMac%E4%B8%ADSublime-Text3%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.下载汉化文件Default.sublime-package 2.打开 Sublime Text3选择Sublime Text–Preferences–Browse Packages点开后会自动打开Finder 如下图 3.找到Installed Packages点击图中上方的Installed Packages 如下图 4.复制文件到Installed Packages中将下载的Default.sublime-package放在Installed Packages文件夹中 3.完成汉化]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred中Workflow的简单案例--新建文件]]></title>
    <url>%2F2017%2F02%2F15%2FAlfred%E4%B8%ADWorkflow%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B--%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[从头构建一个“新建文件”功能的workflow文件自从使用了macbook之后，我便在网络上大量搜索能够有效提高效率的软件，大部分人的推荐都会有一个叫做Alfred的应用,这篇文章讲解了一个简单的alfredworkflow是如何写出来的。 什么是Alfred?Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac. 点击进入Alfred官网Workflow汇总 直切主题，有自己写workflow想法的你肯定已经知道什么是Alfred、怎么使用Alfred，但实际上自己写一个workflow真的很简单。下面我会一步一步的整理出我是如何写出这一简单的功能的。 1.设置Workflow Defaults1.1打开Alfred打开Alfred的Workflow，点击左下角的加号。 1.2填写基本信息 2.创建Blank Workflow2.1新建Blank Workflow 2.2填写信息分别为workflow名称、功能描述、功能分类，图中右上角的方框是workflow的Icon，支持拖拽找到图片直接拖进去即可。 2.3得到workflow界面 3.制作Workflow3.1 新建Inputs在界面上右键得到如下图结果，选择Inputs中的Keyword 3.1.1 填写自定义信息得到如下图结果，填写你想要设置的 激活词组 、标题以及简介，我这里定义成new。 3.1.2实际使用演示 3.2 新建Actions在界面上右键得到如下图结果，选择Actions中的Run NSAppleScript 3.2.1 编辑代码双击得到如下图结果，接着双击转到代码编辑页面将your script here更换成你想要实现的功能的代码即可,当然此处只能用Apple的script来写。 此处我的代码是 on alfred_script(q) tell application &quot;Finder&quot; set selection to make new file at (get insertion location) end tell end alfred_script 如果想用其他语言在请选择在3.2时选择Run Script即可，可以自己选择所用语言，如下图 3.2.2连接模块 4.结果 5.附导出文件new-file.alfredworkflow]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法简介]]></title>
    <url>%2F2017%2F02%2F15%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[主要内容以下内容来源于younghz的Github Markdown是什么？谁发明了这么个东西？为什么要使用它？怎么使用？都谁在用？感觉有意思？不怕你看见，就怕你试试 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. _谁_发明了这么个东西？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案居然被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途（又是一位犹太人）。 3. 为什么要使用它？ 它是易读（看起开舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰的组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. _怎么_使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 废话太多，下面正文，Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); } 注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，_斜体_粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 都_谁_在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 感觉有意思？趁热打铁，推荐几个_工具_。 Chrome下的stackedit插件可以离线使用，很爽。也不用担心平台受限。在线的dillinger.io算是评价好的了，可是不能离线使用。 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。推荐。 Linux下的ReText不错。 其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。我现在使用马克飞象 + Markdown-here，先编辑好，然后一键格式化，挺方便。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。 以上基本是所有traditonal markdown的语法。 补充：随着macOS 10.12的更新，Mou已经无法在新系统上使用，推荐的Markdown编辑器有MWeb、Ulysses、Byword等。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>优秀文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2F2017%2F02%2F11%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下链接不是详细的教你如何一步一步实现完整页面的，只是提供了我在完成整套页面的过程中遇到的问题的最优答案。很多棘手的问题在这些链接前迎刃而解。 &nbsp;&nbsp;1. HEXO官方网站 &nbsp;&nbsp;2. Next主题Github &nbsp;&nbsp;3. Next主题使用文档 &nbsp;&nbsp;4. 在配置Next过程中遇到归档、分类时官网教程不完善]]></content>
      <categories>
        <category>日常所作</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
